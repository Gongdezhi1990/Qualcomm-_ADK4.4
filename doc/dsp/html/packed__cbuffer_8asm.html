<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Kalimba DSP Reference Guide: core/packed_cbuffer.asm File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Kalimba DSP Reference Guide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_4270bfced15e0e73154b13468c7c9ad9.html">core</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">packed_cbuffer.asm File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6f0a22775d0442ff2a691578b2c2c9a7"><td class="memItemLeft" align="right" valign="top">Module: $M.packed_cbuffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="packed__cbuffer_8asm.html#a6f0a22775d0442ff2a691578b2c2c9a7">normalize_read_address</a> </td></tr>
<tr class="memdesc:a6f0a22775d0442ff2a691578b2c2c9a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This module corrects the condition where the READ_BYTE_POS == -1. (ie no more data can be read from the current word, but the read pointer has yet to be advanced. The functions in packed_cbufffer.asm and packed buffer cbops will never leave the buffer in this condition, however, some CODECS will... The condition is corrected by advancing the read pointer, AND resetting READ_BYTEPOS to 2. This normalization will not results in a change to the value returned by packed_cbuffer.calc_amount_data/space, but will allow read operations to be conducted on the packed buffer.  <a href="#a6f0a22775d0442ff2a691578b2c2c9a7">More...</a><br /></td></tr>
<tr class="separator:a6f0a22775d0442ff2a691578b2c2c9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d022c987ba5780bcb6b8e634b589ec8"><td class="memItemLeft" align="right" valign="top">Module: $M.packed_cbuffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="packed__cbuffer_8asm.html#a8d022c987ba5780bcb6b8e634b589ec8">normalize_write_address</a> </td></tr>
<tr class="memdesc:a8d022c987ba5780bcb6b8e634b589ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This module corrects the condition where the WRITE_BYTE_POS == -1. (ie no more data can be written to the current word, but the write pointer has yet to be advanced. The functions in packed_cbufffer.asm and packed buffer cbops will never leave the buffer in this condition, however, some CODECs will... The condition is corrected by advancing the write pointer, AND resetting WRITE_BYTEPOS to 2. This normalization will not results in a change to the value returned by packed_cbuffer.calc_amount_data/space, but will allow write operations to be conducted on the packed buffer.  <a href="#a8d022c987ba5780bcb6b8e634b589ec8">More...</a><br /></td></tr>
<tr class="separator:a8d022c987ba5780bcb6b8e634b589ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa4a9bd3e4d73d5b63a9f8d2db02dc05a"><td class="memItemLeft" align="right" valign="top">Module: $M.packed_cbuffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="packed__cbuffer_8asm.html#aa4a9bd3e4d73d5b63a9f8d2db02dc05a">calc_amount_data</a></td></tr>
<tr class="memdesc:aa4a9bd3e4d73d5b63a9f8d2db02dc05a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the amount of data already in a cbuffer/port.  <a href="#aa4a9bd3e4d73d5b63a9f8d2db02dc05a">More...</a><br /></td></tr>
<tr class="separator:aa4a9bd3e4d73d5b63a9f8d2db02dc05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e1e9cce5ac2414970c68ec07fde622"><td class="memItemLeft" align="right" valign="top">Module: $M.packed_cbuffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="packed__cbuffer_8asm.html#a46e1e9cce5ac2414970c68ec07fde622">calc_amount_space</a></td></tr>
<tr class="memdesc:a46e1e9cce5ac2414970c68ec07fde622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the amount of space for new data in a cbuffer/port.  <a href="#a46e1e9cce5ac2414970c68ec07fde622">More...</a><br /></td></tr>
<tr class="separator:a46e1e9cce5ac2414970c68ec07fde622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada10e7a558e04c313ea8c757b59e9256"><td class="memItemLeft" align="right" valign="top">Module: $M.packed_cbuffer get&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="packed__cbuffer_8asm.html#ada10e7a558e04c313ea8c757b59e9256">set_read_address_and_bytepos</a></td></tr>
<tr class="memdesc:ada10e7a558e04c313ea8c757b59e9256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the buffer's read address and READ_BYTEPOS. Valid values for READ_BYTEPOS are 2,1,0, and -1.  <a href="#ada10e7a558e04c313ea8c757b59e9256">More...</a><br /></td></tr>
<tr class="separator:ada10e7a558e04c313ea8c757b59e9256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f39dcc002a1ebbab71c79229358a1d6"><td class="memItemLeft" align="right" valign="top">Module: $M.packed_cbuffer get&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="packed__cbuffer_8asm.html#a2f39dcc002a1ebbab71c79229358a1d6">set_write_address_and_bytepos</a></td></tr>
<tr class="memdesc:a2f39dcc002a1ebbab71c79229358a1d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the buffer's write address and WRITE_BYTEPOS. Valid values for WRITE_BYTEPOS are 2,1,0, and -1.  <a href="#a2f39dcc002a1ebbab71c79229358a1d6">More...</a><br /></td></tr>
<tr class="separator:a2f39dcc002a1ebbab71c79229358a1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047fb9799b2f440e5ad4a80c5546d0ba"><td class="memItemLeft" align="right" valign="top">Module: $M.packed_cbuffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="packed__cbuffer_8asm.html#a047fb9799b2f440e5ad4a80c5546d0ba">put_word8</a></td></tr>
<tr class="memdesc:a047fb9799b2f440e5ad4a80c5546d0ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert a byte into a packed cbuffer. This module is inneficient and not intended to be used for streaming data, but for inserting a single byte into a packed packed buffer.  <a href="#a047fb9799b2f440e5ad4a80c5546d0ba">More...</a><br /></td></tr>
<tr class="separator:a047fb9799b2f440e5ad4a80c5546d0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96a06df4893bb561238aa1ca6371d8c"><td class="memItemLeft" align="right" valign="top">Module: $M.packed_cbuffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="packed__cbuffer_8asm.html#ab96a06df4893bb561238aa1ca6371d8c">get_word8</a></td></tr>
<tr class="memdesc:ab96a06df4893bb561238aa1ca6371d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">retrieve an 8-bit word from a packed cbuffer. This module is inneficient and not intended to be used for streaming data, but for reading a single byte from a packed buffer.  <a href="#ab96a06df4893bb561238aa1ca6371d8c">More...</a><br /></td></tr>
<tr class="separator:ab96a06df4893bb561238aa1ca6371d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd590f2abc094a5181c0d9a40b0cef7"><td class="memItemLeft" align="right" valign="top">Module: $M.packed_cbuffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="packed__cbuffer_8asm.html#addd590f2abc094a5181c0d9a40b0cef7">get_word16</a></td></tr>
<tr class="memdesc:addd590f2abc094a5181c0d9a40b0cef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This module contains functions to retrieve a 16-bit word from a packed cbuffer. The following functions are supported:  <a href="#addd590f2abc094a5181c0d9a40b0cef7">More...</a><br /></td></tr>
<tr class="separator:addd590f2abc094a5181c0d9a40b0cef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af06f39e04bf38f8eab3378e2b48791"><td class="memItemLeft" align="right" valign="top">Module: $M.packed_cbuffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="packed__cbuffer_8asm.html#a7af06f39e04bf38f8eab3378e2b48791">put_word16</a></td></tr>
<tr class="memdesc:a7af06f39e04bf38f8eab3378e2b48791"><td class="mdescLeft">&#160;</td><td class="mdescRight">This module contains functions to insert 16-bit words into a packed cbuffer. The following functions are supported:  <a href="#a7af06f39e04bf38f8eab3378e2b48791">More...</a><br /></td></tr>
<tr class="separator:a7af06f39e04bf38f8eab3378e2b48791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc4a39542e2a8834b9539c9fe2e5298"><td class="memItemLeft" align="right" valign="top">Module: $M.packed_cbuffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="packed__cbuffer_8asm.html#a6bc4a39542e2a8834b9539c9fe2e5298">check_byte_ptr</a></td></tr>
<tr class="separator:a6bc4a39542e2a8834b9539c9fe2e5298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4de8d9d17132cb2ec8b6bcf9397117f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4de8d9d17132cb2ec8b6bcf9397117f"></a>
if Z jump&#160;</td><td class="memItemRight" valign="bottom"><b>ok</b></td></tr>
<tr class="separator:ae4de8d9d17132cb2ec8b6bcf9397117f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ab321314dd60c96b4275655828e00a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72ab321314dd60c96b4275655828e00a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Null</b> = r2 - 1</td></tr>
<tr class="separator:a72ab321314dd60c96b4275655828e00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cb3fea8735f24c994d63e29e2dde197"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0cb3fea8735f24c994d63e29e2dde197"></a>
jump&#160;</td><td class="memItemRight" valign="bottom"><b>$error</b></td></tr>
<tr class="separator:a0cb3fea8735f24c994d63e29e2dde197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c8e9ec3abddf8c08cbca6c08c778fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64c8e9ec3abddf8c08cbca6c08c778fb"></a>
ok&#160;</td><td class="memItemRight" valign="bottom"><b>__pad34__</b></td></tr>
<tr class="separator:a64c8e9ec3abddf8c08cbca6c08c778fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><em>[SDK Folder]</em>/src/kalimba/core/packed_cbuffer.asm</p>
<p>Part of ADK_CSR867x.WIN. 4.4 Packed buffer library</p>
<p>A packed cbuffer differs from a regular cbuffer in that data is byte-aligned, rather than word aligned like a cbuffer. This requires the addition of read/write byte positions fields in order to track the byte position of the associated with the read/write address</p>
<p>This setup allows both compact (packed) storage of non-native sized words, and non word aligned storage of native-sized words. When word sizes larger than a byte are used, they are ordered in big-endian format.</p>
<p>This library provides functions to: -Create packed cbuffers -put and get words of non-native size (8bit or 16bit) into/from packed buffers. -Calculate how many words are stored in packed buffers</p>
<p>The figure below demonstrates storage of some 16-bit words in a K24 packed cbuffer.</p>
<p>word | addr v 2 1 0 -1 &lt;&ndash;byte_pos 0x000000 |[x0_hi]| x0_lo | x1_hi | &lt;----&mdash;read address=0, [read_bytepos=2] 0x000001 | x1_lo | x2_hi | x2_lo | 0x000002 | x3_hi | x3_lo | x4_hi | 0x000003 | x4_lo | x5_hi | x5_lo | 0x000004 | x6_hi | x6_lo | x7_hi | 0x000005 | x7_lo | x8_hi | x8_lo | 0x000006 | x9_hi | x9_lo |(xxxxx)| &lt;----&mdash;write address=6, (write_bytepos=0) ... |&mdash;8b&ndash;|&mdash;8b&ndash;|&ndash;8b&mdash;| |-------&mdash;24b-------&mdash;|</p>
<p>The same data stored in non-packed buffer:</p>
<p>word | addr v 0x000000 | xxxxx | x0_hi | x0_lo | &lt;----&mdash;read address=0 0x000001 | xxxxx | x1_hi | x1_lo | 0x000002 | xxxxx | x2_hi | x2_lo | 0x000003 | xxxxx | x3_hi | x3_lo | 0x000004 | xxxxx | x4_hi | x4_lo | 0x000005 | xxxxx | x5_hi | x5_lo | 0x000006 | xxxxx | x6_hi | x6_lo | 0x000007 | xxxxx | x7_hi | x7_lo | 0x000008 | xxxxx | x8_hi | x8_lo | 0x000009 | xxxxx | x9_hi | x9_lo | 0x00000A | xxxxx | xxxxx | xxxxx | &lt;----&mdash;write address=10 ... |&mdash;8b&ndash;|&mdash;8b&ndash;|&ndash;8b&mdash;| |-------&mdash;24b-------&mdash;|</p>
<p>xxxx = dont't care</p>
<p>A packed cbuffer object contains the following fields: $cbuffer.SIZE_FIELD (0) // inherited from cbuffer object $cbuffer.READ_ADDR_FIELD (1) // inherited from cbuffer object $cbuffer.WRITE_ADDR_FIELD(2) // inherited from cbuffer object $cbuffer.START_ADDR_FIELD (3) // inherited from cbuffer object (base register mode) $packed_cbuffer.READ_BYTEPOS_FIELD (cbuffer.size+1) // current read byte position (0-2 for K24) $packed_cbuffer.WRITE_BYTEPOS_FIELDS (cbuffer.size+2) // current write byte position (0-2 for K24)</p>
<p>Note that the beginning of the object is identical to a regular cbuffer. This means that a packed cbuffer can be passed to cbuffer functions like calc_amount_data, etc</p>
<p>-Buffer updates: Relations below describe how READ_BYTEPOS and WRITE_BYTEPOS are updated, and how data and space in the buffer are calculated...</p>
<p>N = number of bytes transferred to/from packed bufffer sz = packed buffer size in 24-bit words wo = write pointer increment (add to write pointer) ro = read pointer increment (add to read pointer) wb = write byte position (initialize to 2) rb = read byte position (initialize to 2)</p>
<p>-write update (for put operation) wb = (wb-N)%3 // new write bytepos wo = (2-wb+N)/3 // increment for write pointer(24-bit words), how much to increment cbuffer writer_poitner field -read update (for get operation) rb = (rb-N)%3 // new read bytepos ro = (2-rb+N)/3 // increment for read pointer(24-bit words), how much to increment cbuffer read_poitner field -amount_data_bytes = write_byte_pointer - read_byte_pointer = (3*wo+2-wb) - (3*ro+2-rb) = 3*(amount_data_w) + (rb-wb) // amount_data_w comes from $cbuffer.calc_amount_data -amount_space_bytes = sz - (write_byte_pointer - read_byte_pointer) = 3*(sz_w - (wo-ro)-1) + (wb-rb) = 3*(amount_space_w) + (wb-rb) // amount_space_w comes from $cbuffer.calc_amount_space /*! </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a6f0a22775d0442ff2a691578b2c2c9a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$M packed_cbuffer normalize_read_address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This module corrects the condition where the READ_BYTE_POS == -1. (ie no more data can be read from the current word, but the read pointer has yet to be advanced. The functions in packed_cbufffer.asm and packed buffer cbops will never leave the buffer in this condition, however, some CODECS will... The condition is corrected by advancing the read pointer, AND resetting READ_BYTEPOS to 2. This normalization will not results in a change to the value returned by packed_cbuffer.calc_amount_data/space, but will allow read operations to be conducted on the packed buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td>r0 = packed cbuffer struc </td></tr>
    <tr><td class="paramname">OUTPUTS</td><td>none TRASH none </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8d022c987ba5780bcb6b8e634b589ec8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$M packed_cbuffer normalize_write_address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This module corrects the condition where the WRITE_BYTE_POS == -1. (ie no more data can be written to the current word, but the write pointer has yet to be advanced. The functions in packed_cbufffer.asm and packed buffer cbops will never leave the buffer in this condition, however, some CODECs will... The condition is corrected by advancing the write pointer, AND resetting WRITE_BYTEPOS to 2. This normalization will not results in a change to the value returned by packed_cbuffer.calc_amount_data/space, but will allow write operations to be conducted on the packed buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td>r0 = packed cbuffer struc </td></tr>
    <tr><td class="paramname">OUTPUTS</td><td>none TRASH none </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="aa4a9bd3e4d73d5b63a9f8d2db02dc05a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$M packed_cbuffer calc_amount_data</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the amount of data already in a cbuffer/port. </p>
<p>return number of bytes stored in packed buffer = ( 3*(calc_amt_data_w) + rb-wb )</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = pointer to cbuffer structure (for cbuffers) or a port identifier (for ports)</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>r0 = amount of data available in words</li>
<li>r1 = amount of data available in bytes (needed for USB support)</li>
<li>r2 = buffer size in words (bytes if an mmu port)</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r1</dd>
</dl>
<dl>
<dt><b>Notes:</b></dt>
<dd><p class="startdd">If passed a pointer to a cbuffer structure then return the amount of data in the cbuffer. If passed a port identifier then return the amount of data in the port.</p>
<p class="enddd"></p>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td>r0 = packed cbuffer struc r2 = buffer size in 24-bit words</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td>r0 = packed amount data (16-bit words)</td></tr>
  </table>
  </dd>
</dl>
<p>TRASH r1 </p>

</div>
</div>
<a class="anchor" id="a46e1e9cce5ac2414970c68ec07fde622"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$M packed_cbuffer calc_amount_space</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the amount of space for new data in a cbuffer/port. </p>
<p>return number of 16-bit words available in packed buffer =( 3*(calc_amt_space_w) + wb-rb ) / 2</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = pointer to cbuffer structure (for cbuffers) or a port identifier (for ports)</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>r0 = amount of space (for new data) in words</li>
<li>r2 = buffer size in words (bytes if an mmu port)</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r1</dd>
</dl>
<dl>
<dt><b>Notes:</b></dt>
<dd><p class="startdd">If passed a pointer to a cbuffer structure then return the amount of space (for new data) in the cbuffer. If passed a port identifier then return the amount of space (for new data) in the port.</p>
<p class="enddd"></p>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td>r0 = packed cbuffer struc</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td>r0 = packed amount space (16-bit words) r2 = buffer size in 24-bit words</td></tr>
  </table>
  </dd>
</dl>
<p>TRASH r1 </p>

</div>
</div>
<a class="anchor" id="a6bc4a39542e2a8834b9539c9fe2e5298"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$packed_cbuffer check_byte_ptr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>INPUT: r2 = read/write byteptr TRASH: none </p>

</div>
</div>
<a class="anchor" id="addd590f2abc094a5181c0d9a40b0cef7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$M packed_cbuffer get_word16</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This module contains functions to retrieve a 16-bit word from a packed cbuffer. The following functions are supported: </p>
<p>$packed_cbuffer.retrieve_16: Function to unpack a word. Not setup or initialization is required. This funciton is relatively inneficient but easy to use</p>
<p>$packed_cbuffer.retrieve_16_initialize: Initialize system for repeatedly unpacking words. After calling thisi function, call r4 repaeatedly to efficiently read values from the packed buffer</p>
<p>$packed_cbuffer.retrieve_16_finalize: Call this function when finished reading packed data from the buffer</p>
<p>get_pos0/1/2 Function to get data from various byte positions. These should not be called directly</p>
<p>Example of using above functions to read packed data For a more efficient way of reading packed words, rather than calling thiis function, use the following procedure:</p>
<p>initialize call $packed_cbuffer.get_word16_initialize;</p>
<p>call r4 repeatedly to extract four words out of a packed cbuffer (and store them): preserve r6, I1/L1, I5/L5/B5 call r4; call r4, M[I0, M1] = r0; call r4, M[I0, M1] = r0; call r4, M[I0, M1] = r0; M[I0, M1] = r0;</p>
<p>finish $packed_cbuffer.get_word16_finalize </p>

</div>
</div>
<a class="anchor" id="ab96a06df4893bb561238aa1ca6371d8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$M packed_cbuffer get_word8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>retrieve an 8-bit word from a packed cbuffer. This module is inneficient and not intended to be used for streaming data, but for reading a single byte from a packed buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td>r0 = packed_cbuffer pointer</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td>r1 = word read from buffer</td></tr>
  </table>
  </dd>
</dl>
<p>TRASH: r1-r4,I0/L0/B0 </p>

</div>
</div>
<a class="anchor" id="a7af06f39e04bf38f8eab3378e2b48791"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$M packed_cbuffer put_word16</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This module contains functions to insert 16-bit words into a packed cbuffer. The following functions are supported: </p>
<p>$packed_cbuffer.insert_16: Function to pack a word. No setup or initialization is required. This funciton is relatively inneficient but easy to use</p>
<p>$packed_cbuffer.insert_16_initialize: Initialize system for repeatedly packing words. After calling thisi function, call r5 repaeatedly to efficiently read values from the packed buffer</p>
<p>$packed_cbuffer.insert_16_finalize: Call this function when finished reading packed data from the buffer</p>
<p>write_at_pos0/1/2 Function to get data from various byte positions. These should not be called directly</p>
<p>Example of using above functions to read packed data For a more efficient way of reading packed words, rather than calling thiis function, use the following procedure:</p>
<p>initialize call $packed_cbuffer.put_word16_initialize;</p>
<p>call r5 repeatedly to pack words into a packed buffer preserve r6, I0/L0/B0, I4/L4, M0,M1 r0 = M[I1, M1]; call r5, r0 = M[I1, M1]; call r5, r0 = M[I1, M1]; call r5, r0 = M[I1, M1];</p>
<p>finish $packed_cbuffer.put_word16_finalize </p>

</div>
</div>
<a class="anchor" id="a047fb9799b2f440e5ad4a80c5546d0ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$M packed_cbuffer put_word8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>insert a byte into a packed cbuffer. This module is inneficient and not intended to be used for streaming data, but for inserting a single byte into a packed packed buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td>r0 = packed_cbuffer pointer r1 = word to insert to buffer</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td>none</td></tr>
  </table>
  </dd>
</dl>
<p>TRASH: r1-r4,I0/L0/B0 </p>

</div>
</div>
<a class="anchor" id="ada10e7a558e04c313ea8c757b59e9256"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$M packed_cbuffer get set_read_address_and_bytepos</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the buffer's read address and READ_BYTEPOS. Valid values for READ_BYTEPOS are 2,1,0, and -1. </p>
<p>Note a bytepos value of -1 (a state set by some CODECS) is considered an abnormal state, and while calc_amount_data/space will return a valid value, buffer operations cannot take place during this condition (packked buffer manipulation functions will call the packed_buffer.normalize function to correcft it first)</p>
<p>When converting between bit position used by some CODECs, and BYTEPOS, use the following relation: READ_BYTEPOS = (sbcdec.get_bitpos &gt;&gt; 3) - 1; sbc.bitpos READ_BYTEPOS 24 2 23-16 1 15-8 0 7-0 -1 where: sbcdec.get_bitpos = [24...0]; // bit position, 0 means READ_BYTEPOS = [2, 1, 0, -1] // see above</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td>r0 = packed cbuffer struc r1 = read address (set/get) r2 = read_bytepos (-1, 0, 1, 2) (set/get) r3 = length (get) r4 = start address (get)</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td>none</td></tr>
  </table>
  </dd>
</dl>
<p>TRASH none </p>

</div>
</div>
<a class="anchor" id="a2f39dcc002a1ebbab71c79229358a1d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$M packed_cbuffer get set_write_address_and_bytepos</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the buffer's write address and WRITE_BYTEPOS. Valid values for WRITE_BYTEPOS are 2,1,0, and -1. </p>
<p>Note a bytepos value of -1 (a state set by some CODECS) is considered an abnormal state, and while calc_amount_data/space will return a valid value, buffer operations cannot take place during this condition (packked buffer manipulation functions will call the packed_buffer.normalize function to correcft it first)</p>
<p>When converting between bit position used by some CODECs, and BYTEPOS, use the following relation: WRITE_BYTEPOS = (sbcdec.set_bitpos &gt;&gt; 3) - 1; sbc.bitpos WRITE_BYTEPOS 24 2 23-16 1 15-8 0 7-0 -1 where: sbcdec.get_bitpos = [24...0]; // bit position, 0 means WRITE_BYTEPOS = [2, 1, 0, -1] // see above</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td>r0 = packed cbuffer struc r1 = write address (get/set) r2 = write_bytepos (-1, 0, 1, 2) (get/set) r3 = length (get) r4 = start (get)</td></tr>
  </table>
  </dd>
</dl>
<p>TRASH none </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 3 2018 03:05:07 for Kalimba DSP Reference Guide by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
