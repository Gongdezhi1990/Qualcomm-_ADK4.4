<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Kalimba DSP Reference Guide: cbops/operators/cbops_silence_clip_detect.asm File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Kalimba DSP Reference Guide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_2e7bb94b659ebdb4d604e8a4d2bc22e0.html">cbops</a></li><li class="navelem"><a class="el" href="dir_ea60bc174a9f695c0dc189311fa15b02.html">operators</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cbops_silence_clip_detect.asm File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This operator monitors the sample values in the input buffer and compares it to the lower (silence) and upper (clip) thresholds. If the signal clips or is silent for the specified duration a message is sent to the VM.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a27c04e8d76deede14aa01ec5513b8573"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27c04e8d76deede14aa01ec5513b8573"></a>
Module: $cbops.silence_clip_detect&#160;</td><td class="memItemRight" valign="bottom"><b>reset</b> </td></tr>
<tr class="separator:a27c04e8d76deede14aa01ec5513b8573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbde195ef5ef1d01a8c3a787b5eba963"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbde195ef5ef1d01a8c3a787b5eba963"></a>
Module: $cbops.silence_clip_detect&#160;</td><td class="memItemRight" valign="bottom"><b>main</b> </td></tr>
<tr class="separator:adbde195ef5ef1d01a8c3a787b5eba963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3727a89bc8f634d47f515adf3073f58"><td class="memItemLeft" align="right" valign="top">Module: $cbops.silence_clip_detect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbops__silence__clip__detect_8asm.html#ab3727a89bc8f634d47f515adf3073f58">initialise</a> </td></tr>
<tr class="memdesc:ab3727a89bc8f634d47f515adf3073f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialisation routine for the silence and clipping detect operator. During its first call the routine initialises a message handler to receive all messages from the VM to start/stop monitoring.  <a href="#ab3727a89bc8f634d47f515adf3073f58">More...</a><br /></td></tr>
<tr class="separator:ab3727a89bc8f634d47f515adf3073f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2927fbc107cb7a1aad0bc1650037f184"><td class="memItemLeft" align="right" valign="top">Module: $cbops.silence_clip_detect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbops__silence__clip__detect_8asm.html#a2927fbc107cb7a1aad0bc1650037f184">message_handler</a> </td></tr>
<tr class="memdesc:a2927fbc107cb7a1aad0bc1650037f184"><td class="mdescLeft">&#160;</td><td class="mdescRight">The message handler for messages from the VM to set the silence period for the silence detector and to set the clip threshold sample value.  <a href="#a2927fbc107cb7a1aad0bc1650037f184">More...</a><br /></td></tr>
<tr class="separator:a2927fbc107cb7a1aad0bc1650037f184"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This operator monitors the sample values in the input buffer and compares it to the lower (silence) and upper (clip) thresholds. If the signal clips or is silent for the specified duration a message is sent to the VM. </p>
<p><em>[SDK Folder]</em>/src/kalimba/operators/cbops_silence_clip_detect.asm</p>
<p>Part of ADK_CSR867x.WIN. 4.4</p>
<h1>Silence And Clip Detect Operator</h1>
<p>This operator does not copy any samples. Hence, it does not require an output buffer. It just analyses the contents of the input buffer.</p>
<p>In most applications each instance will start with its parameter area virtually empty. The only elements populated will be the INPUT_START_INDEX_FIELD and the INSTANCE_NO_FIELD (see below). The remaining fields will be populated by a message from the VM with levels and/or durations.</p>
<p>When using the operator the following data structure is used:</p><ul>
<li>$cbops.silence_clip_detect.INPUT_START_INDEX_FIELD = the input buffer that is being analysed</li>
<li>$cbops.silence_clip_detect.INSTANCE_NO_FIELD = The instance number of this detector operator. Up to 8 instances can be used (one for each channel of audio)</li>
<li>$cbops.silence_clip_detect.SILENCE_LIMIT_FIELD = the threshold value used for the silence detector. If the sample values are below this threshold the time counter is started. If the sample values exceed this threshold the time counter is reset. Initialise to zero.</li>
<li>$cbops.silence_clip_detect.CLIP_LIMIT_FIELD = the threshold value used for the clip detector. If the signal exceeds this value a message is sent to the VM. Initialise to zero.</li>
<li>$cbops.silence_clip_detect.SILENCE_PERIOD_LSW_FIELD = The LSW of the current duration of silence that has been detected. Initialise to zero.</li>
<li>$cbops.silence_clip_detect.SILENCE_PERIOD_MSW_FIELD = The MSW of the current duration of silence that has been detected. Initialise to zero.</li>
<li>$cbops.silence_clip_detect.PREVIOUS_TIME_FIELD = the time this operator was previously called. Initialise to zero.</li>
<li>$cbops.silence_clip_detect.SILENCE_AMOUNT_LSW_FIELD = The LSW of the silence duration after which a message is sent to the VM. Initialise to zero.</li>
<li>$cbops.silence_clip_detect.SILENCE_AMOUNT_MSW_FIELD = The MSW of the silence duration after which a message is sent to the VM. Initialise to zero. </li>
</ul>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ab3727a89bc8f634d47f515adf3073f58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$spi_comm initialise </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialisation routine for the silence and clipping detect operator. During its first call the routine initialises a message handler to receive all messages from the VM to start/stop monitoring. </p>
<p>Initialise spi message system. We set the cmd_ready flag in the spi block to be equal to SPI CLEAR.</p>
<p>Initialise the rotary encoder library.</p>
<p>Initialise the pulse_led library.</p>
<ul>
<li>Initialise malloc library.</li>
</ul>
<p>This routine initialises the DTMF library. It registers $dtmf.received_message_handler to receive messages from the VM, initialises the supplied DTMF structure and stores the address of the structure.</p>
<p>Initialise the wall clock library.</p>
<p>Initialise the software stack.</p>
<p>Initialises the PS key library.</p>
<p>Initialise the profiler library.</p>
<p>Initialises the monitoring of PIOs.</p>
<p>Initialise message system.</p>
<p>Initialise the interrupt controller.</p>
<p>Initialises the fwrandom library.</p>
<p>Initialise cbuffer library.</p>
<p>NOTE - this routine must be called once for each instance to be used - ie if this is to be used on a stereo stream one instance will be required for each channel. Each instance must be assigned a different instance number and registered with the initialise routine seperately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r8 = pointer to operator structure</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0 - r4</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0, r1, r2, r3</dd>
</dl>
<dl>
<dt><b>Notes:</b></dt>
<dd><p class="startdd">Should be called after $message.initialise since it sets up the message handler for buffer configuring.</p>
<p class="enddd"></p>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r1, r2, r3</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0</dd>
</dl>
<dl>
<dt><b>Notes:</b></dt>
<dd><p class="startdd">Should be called before interrupts are initialised (or at least before any messages will be sent/received)</p>
<p class="enddd"></p>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0, r1, r2, r3, r4, r5, r10, DoLoop</dd>
</dl>
<dl>
<dt><b>Notes:</b></dt>
<dd><p class="startdd">Should be called before the timer library has been initialised.</p>
<p class="enddd"></p>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>r9 = the stack pointer</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>none</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0, r1, r2, r3</dd>
</dl>
<dl>
<dt><b>Notes:</b></dt>
<dd><p class="startdd">Should be called after $message.initialise since it sets up a message handler for the firmware 'wall clock' message.</p>
<p class="enddd"></p>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r8 = pointer to dtmf structure to use</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>- r0, r1, r2, r3,</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td>r0 = DM1 area pointer (NOTE: THIS SHOULD NOT BE ZERO) r1 = DM1 area size r2 = DM2 area pointer r3 = DM2 area size</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd></dd>
</dl>
<p>NOTE: DM1 area should not start at 0 as the is the failure return code for the alloc routine</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = patch RAM start address</li>
<li>r1 = patch RAM size</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>- r2, r3</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = patch structure pointer</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>- r0, r10, I0, DoLoop</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0, r1, r2, r3</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0, r1, r2</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0</dd>
</dl>
<dl>
<dt><b>Notes:</b></dt>
<dd></dd>
</dl>

</div>
</div>
<a class="anchor" id="a2927fbc107cb7a1aad0bc1650037f184"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$rotary_enc message_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The message handler for messages from the VM to set the silence period for the silence detector and to set the clip threshold sample value. </p>
<p>Extracts the details (from the VM message) about the rotary encoder.</p>
<p>Message handler for the $MESSAGE_PULSE_LED message from the VM 1st message argument - PIO_MASK to use for pulsing LED 2nd message argument - pulsing period (units are approx 0.35secs, e.g. 4 equates to a 1.4sec pulsing period)</p>
<p>Message handler for $LONG_MESSAGE_WALL_CLOCK_RESPONSE and $LONG_MESSAGE_WALL_CLOCK_RESPONSE_TBTA messages.</p>
<p>Message handler to receive messages from Firmware and forward onto the registered 'get_file_address' handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r1 = instance number</li>
<li>r2 = silence level (a signed 16 bit number represeting -1.0 -&gt; +1.0) negative values will be intepreted as a message to switch the detection off</li>
<li>r3 = duration of silence in seconds</li>
<li>r4 = clipping level (a signed 16 bit number represeting -1.0 -&gt; +1.0) negative values will be intepreted as a message to switch the detection off.</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r8</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = message ID ($MESSAGE_FILE_ADDRESS)</li>
<li>r1 = message Data 0 (VM file handle)</li>
<li>r2 = message Data 1 (lower 16bits of address)</li>
<li>r3 = message Data 2 (upper 16bits of address)</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>Assume everything</dd>
</dl>
<dl>
<dt><b>Notes:</b></dt>
<dd>The registered handler is called with the registers populated as follows: <pre class="fragment">   Register         Description
   --------         ---------------
      r1            VM file handle
      r2            24-bit absolute flash address of start of file
</pre> </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = message ID</li>
<li>r3 = message pointer: Data 0 (BT address: Type) If LONG_MESSAGE_WALL_CLOCK_RESPONSE_TBTA. The rest the same as below. Data 0 or 1 (BT address: NAP) Data 1 or 2 (BT address: UAP (in MS 8 bits) + MS byte of LAP) Data 2 or 3 (BT address: LS word of LAP) Data 3 or 4 (Wall clock MSW) Data 4 or 5 (Wall clock LSW) Data 5 or 6 (Timestamp MSW) Data 6 or 7 (Timestamp LSW)</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>assume all</dd>
</dl>
<dl>
<dt><b>Notes:</b></dt>
<dd>In case of the _TBTA message one extra word will be placed at the top of the message. </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0-r5, r10, DoLoop</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = Message ID of message from VM</li>
<li>r1 = PIO mask</li>
<li>r2 = min period</li>
<li>r3 = max bounce</li>
<li>r4 = msg return ID</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>All (ISR will restore)</dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 3 2018 03:05:06 for Kalimba DSP Reference Guide by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
