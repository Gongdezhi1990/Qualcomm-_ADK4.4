<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Kalimba DSP Reference Guide: frame_sync/usbio.asm File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Kalimba DSP Reference Guide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_1706797bd6f3daf39bf15ba25aeb2307.html">frame_sync</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">usbio.asm File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This library provides an API for dealing with transferring data between a USB MMU Port and cbuffers.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0ff1660192d228e00ca4c2e4c78efc39"><td class="memItemLeft" align="right" valign="top">Module: $frame_sync.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbio_8asm.html#a0ff1660192d228e00ca4c2e4c78efc39">usb_in_stereo_audio_copy</a> </td></tr>
<tr class="memdesc:a0ff1660192d228e00ca4c2e4c78efc39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy available USB audio data from a read port to two cbuffers.  <a href="#a0ff1660192d228e00ca4c2e4c78efc39">More...</a><br /></td></tr>
<tr class="separator:a0ff1660192d228e00ca4c2e4c78efc39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3eab7e75c4845eb29781f5df3d75362"><td class="memItemLeft" align="right" valign="top">Module: $frame_sync.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbio_8asm.html#af3eab7e75c4845eb29781f5df3d75362">usb_in_mono_audio_copy</a> </td></tr>
<tr class="memdesc:af3eab7e75c4845eb29781f5df3d75362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy available USB audio data from a read port to two cbuffers.  <a href="#af3eab7e75c4845eb29781f5df3d75362">More...</a><br /></td></tr>
<tr class="separator:af3eab7e75c4845eb29781f5df3d75362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa6528ae721d3b286c3871ef088b5779"><td class="memItemLeft" align="right" valign="top">Module: $frame_sync.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbio_8asm.html#aaa6528ae721d3b286c3871ef088b5779">usb_out_stereo_copy</a> </td></tr>
<tr class="memdesc:aaa6528ae721d3b286c3871ef088b5779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy available usb audio data from 2 cbuffers.  <a href="#aaa6528ae721d3b286c3871ef088b5779">More...</a><br /></td></tr>
<tr class="separator:aaa6528ae721d3b286c3871ef088b5779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac362cad03c97d1f9f96670895ec090"><td class="memItemLeft" align="right" valign="top">Module: $frame_sync.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbio_8asm.html#abac362cad03c97d1f9f96670895ec090">usb_out_mono_copy</a> </td></tr>
<tr class="memdesc:abac362cad03c97d1f9f96670895ec090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy available usb audio data from 1 cbuffer.  <a href="#abac362cad03c97d1f9f96670895ec090">More...</a><br /></td></tr>
<tr class="separator:abac362cad03c97d1f9f96670895ec090"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This library provides an API for dealing with transferring data between a USB MMU Port and cbuffers. </p>
<p><em>[SDK Folder]</em>/src/kalimba/frame_sync/usbio.asm</p>
<p>Part of ADK_CSR867x.WIN. 4.4</p>
<p>Define FRAME_SYNC_DEBUG here to allow USBIO debug (this is also enabled by frame sync debug build variant) #define FRAME_SYNC_DEBUG Define USB_IN_RETRYS to allow more than one USB input packet per timer interrupt</p>
<h1>USB IO Library</h1>
<p>For reading from a USB MMU port a specific protocal is required to extract the data. Due to this protocal interpretation the read operation does not fit into the CBOPs operator architecture. Also, read operations should be performed based on USB audio packet size which is always 1 msec of audio regardless of sample rate.</p>
<p>Based on the above constraints the USB copy in functions should be called directly, within a 1 msec timer task.</p>
<p>For stereo USB audio TBD</p>
<p>For Mono USB audio TBD</p>
<p>For writing to a USB MMU port the CBOPs operator architecture is supported. For Mono USB audio the standard operator set may be used. However, to manage stereo USB audio a function is provided in this library.</p>
<p>Both the API for reading USB data and the operators for writing USB data are designed to operate with the frame sync architecture. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="af3eab7e75c4845eb29781f5df3d75362"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$frame_sync usb_in_mono_audio_copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy available USB audio data from a read port to two cbuffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r8 = pointer to operator structure:<ul>
<li>USB_IN_MONO_COPY_SOURCE_FIELD [In] USB input port (port ID)</li>
<li>USB_IN_MONO_COPY_SINK_FIELD [In] Audio output cbuffer (address of cbuffer structure)</li>
<li>USB_IN_MONO_COPY_PACKET_LENGTH_FIELD [In] Length of "large" USB packet in bytes (e.g. 96)</li>
<li>USB_IN_MONO_COPY_SHIFT_AMOUNT_FIELD [In] Gain shift applied to the samples on output</li>
<li>USB_IN_MONO_COPY_LAST_HEADER_FIELD Previous sync byte value received (0..0x7f)</li>
<li>USB_IN_MONO_PACKET_COUNT_MODULO_FIELD [In] Packet sequence period in packets (e.g. 10 gives: 9 small, 1 large)</li>
<li>USB_IN_MONO_STATE_FIELD USB input state</li>
<li>USB_IN_MONO_PACKET_COUNTER_FIELD Packet counter (0..$frame_sync.USB_IN_MONO_PACKET_COUNT_MODULO_FIELD - 1)</li>
</ul>
</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0, r1, r2, r3, r4, r6, r7, I0, I4, L0 = 0, r10, DoLoop</dd>
</dl>
<dl>
<dt><b>Notes:</b></dt>
<dd><p class="startdd">When enumerating on USB as a sound device we get a single byte stream of data. This consists of a byte of header followed by a number of 16bit samples. USB 16bit samples are LSbyte first which is the MMU port's default mode.</p>
<p>If the input USB port stalls (i.e. there is no data available) then no special action is taken.</p>
<p class="enddd"></p>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a0ff1660192d228e00ca4c2e4c78efc39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$frame_sync usb_in_stereo_audio_copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy available USB audio data from a read port to two cbuffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r8 = pointer to operator structure:<ul>
<li>USB_IN_STEREO_COPY_SOURCE_FIELD [In] USB input port (port ID)</li>
<li>USB_IN_STEREO_COPY_LEFT_SINK_FIELD [In] Left audio output cbuffer (address of cbuffer structure)</li>
<li>USB_IN_STEREO_COPY_RIGHT_SINK_FIELD [In] Right audio output cbuffer (address of cbuffer structure)</li>
<li>USB_IN_STEREO_COPY_PACKET_LENGTH_FIELD [In] Length of "large" USB packet in bytes (e.g. 192)</li>
<li>USB_IN_STEREO_COPY_SHIFT_AMOUNT_FIELD [In] Gain shift applied to the samples on output</li>
<li>USB_IN_STEREO_COPY_LAST_HEADER_FIELD Previous sync byte value received (0..0x7f)</li>
<li>USB_IN_STEREO_PACKET_COUNT_MODULO_FIELD [In] Packet sequence period in packets (e.g. 10 gives: 9 small, 1 large)</li>
<li>USB_IN_STEREO_STATE_FIELD USB input state</li>
<li>USB_IN_STEREO_PACKET_COUNTER_FIELD Packet counter (0..$frame_sync.USB_IN_STEREO_PACKET_COUNT_MODULO_FIELD - 1)</li>
</ul>
</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0, r1, r2, r3, r4, r6, r7, I0, I4, I5, L0 = 0, L5 = 0, r10, DoLoop</dd>
</dl>
<dl>
<dt><b>Notes:</b></dt>
<dd><p class="startdd">When enumerating on USB as a sound device we get a single byte stream of data. This consists of a byte of header followed by a number of 16bit samples. If stereo mode is selected then samples are alternately left and then right. USB 16bit samples are LSbyte first which is the MMU port's default mode.</p>
<p>If the input USB port stalls (i.e. there is no data available) then no special action is taken.</p>
<p class="enddd"></p>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="abac362cad03c97d1f9f96670895ec090"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$frame_sync usb_out_mono_copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy available usb audio data from 1 cbuffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r8 = pointer to structure:</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>TRASHED:</p><ul>
<li>r0, r1, r2, r3, r4, r5, I0, M0, doLoop</li>
</ul>
<dl>
<dt><b>Notes:</b></dt>
<dd><p class="startdd">This driver attempts to maintain one packet (1ms worth) of data in the port.</p>
<p>Because of jitter, it should be run at a sub-1ms interval (ie 750us).</p>
<p>If it must be run at a &gt;=1ms interval, then TRANSFER_PER_PERIOD_FEILD should be increased to ensure that the port never runs out of data.</p>
<p>NOTE: No latency control implemented.</p>
<p class="enddd"></p>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="aaa6528ae721d3b286c3871ef088b5779"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$frame_sync usb_out_stereo_copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy available usb audio data from 2 cbuffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r8 = pointer to structure:</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>TRASHED:</p><ul>
<li>r0, r1, r2, r3, r4, r5, I0, I4, M0, doLoop</li>
</ul>
<p>The audio data is interlaced left/right into the USB MMU port </p><dl>
<dt><b>Notes:</b></dt>
<dd><p class="startdd">This driver attempts to maintain one packet (1ms worth) of data in the port.</p>
<p>Because of jitter, it should be run at a sub-1ms interval (ie 750us).</p>
<p>If it must be run at a &gt;=1ms interval, then TRANSFER_PER_PERIOD_FEILD should be increased to ensure that the port never runs out of data.</p>
<p class="enddd">NOTE: No latency control implemented. </p>
</dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 3 2018 03:05:07 for Kalimba DSP Reference Guide by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
