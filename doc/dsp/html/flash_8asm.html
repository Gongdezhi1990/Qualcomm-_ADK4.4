<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Kalimba DSP Reference Guide: core/flash.asm File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Kalimba DSP Reference Guide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_4270bfced15e0e73154b13468c7c9ad9.html">core</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">flash.asm File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This library provides an API to aid accessing data from the onchip flash memory from kalimba. Access to flash using BC3-MM is quite slow, it takes approx 2us (64 DSP clock cycles) per word. Using BC5-MM it is faster, but the access time still depends on the speed of the flash part used and the MCU's clock rate and workload. Typically with a 70ns flash the DSP will take 9 cycles (at 64MHz) to access a 16bit word from flash.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad446219a7776a8cbf823a64ccdb7450d"><td class="memItemLeft" align="right" valign="top">Module: $flash.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flash_8asm.html#ad446219a7776a8cbf823a64ccdb7450d">init_pm</a> </td></tr>
<tr class="memdesc:ad446219a7776a8cbf823a64ccdb7450d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises the PM_FLASH segment.  <a href="#ad446219a7776a8cbf823a64ccdb7450d">More...</a><br /></td></tr>
<tr class="separator:ad446219a7776a8cbf823a64ccdb7450d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523451630caac7174f478b959999e1be"><td class="memItemLeft" align="right" valign="top">Module: $flash.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flash_8asm.html#a523451630caac7174f478b959999e1be">init_dmconst</a> </td></tr>
<tr class="memdesc:a523451630caac7174f478b959999e1be"><td class="mdescLeft">&#160;</td><td class="mdescRight">On a BC7 initialises flash data to be mapped into windows 2 and 3. 24-bit data (corresponding to DMCONST) is mapped into window 3, while 16-bit data is mapped into window 2.  <a href="#a523451630caac7174f478b959999e1be">More...</a><br /></td></tr>
<tr class="separator:a523451630caac7174f478b959999e1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f94e501a439af88ef44c87a515273a2"><td class="memItemLeft" align="right" valign="top">Module: $flash.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flash_8asm.html#a6f94e501a439af88ef44c87a515273a2">map_page_into_dm</a> </td></tr>
<tr class="memdesc:a6f94e501a439af88ef44c87a515273a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the address of a 'flash segment' variable this routine will map in the appropriate flash page required and return a pointer to the DM2 flash window to access it.  <a href="#a6f94e501a439af88ef44c87a515273a2">More...</a><br /></td></tr>
<tr class="separator:a6f94e501a439af88ef44c87a515273a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae59f51797b4219dddd619dd3a8784402"><td class="memItemLeft" align="right" valign="top">Module: $flash.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flash_8asm.html#ae59f51797b4219dddd619dd3a8784402">copy_to_dm</a> </td></tr>
<tr class="memdesc:ae59f51797b4219dddd619dd3a8784402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the address of a 'flash segment' variable and its size this routine will copy the variable to a place in data memory ram. It will automatically switch flash pages as needed if the variable overlaps a flash page boundary.  <a href="#ae59f51797b4219dddd619dd3a8784402">More...</a><br /></td></tr>
<tr class="separator:ae59f51797b4219dddd619dd3a8784402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f8bd277fa9476a4cac9890e226d847"><td class="memItemLeft" align="right" valign="top">Module: $flash.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flash_8asm.html#a73f8bd277fa9476a4cac9890e226d847">copy_to_dm_32_to_24</a> </td></tr>
<tr class="memdesc:a73f8bd277fa9476a4cac9890e226d847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the address of a 'flash segment' variable and its size this routine will copy the variable to a place in data memory ram. It will automatically switch flash pages as needed if the variable overlaps a flash page boundary. each 24-bit data, 0xABCDEF, is stored in 2 words in flash:  <a href="#a73f8bd277fa9476a4cac9890e226d847">More...</a><br /></td></tr>
<tr class="separator:a73f8bd277fa9476a4cac9890e226d847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86fce22fd026c7cbbb4c3e524a359076"><td class="memItemLeft" align="right" valign="top">Module: $flash.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flash_8asm.html#a86fce22fd026c7cbbb4c3e524a359076">copy_to_dm_24</a> </td></tr>
<tr class="memdesc:a86fce22fd026c7cbbb4c3e524a359076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the address of a 'flash segment' variable and its size this routine will copy and unpack 24-bit data to a place in data memory ram. It will automatically switch flash pages as needed if the variable overlaps a flash page boundary. 24-bit data in flash is packed as follows: addr 0: (word 0) bits 23-8 addr 1: (word 0) bits 7-0 (word 1) bits 23-16 addr 2: (word 1) bits 15-0 addr 3: (word 2) bits 23-8 addr 4: (word 2) bits 7-0 (word 3) bits 23-16 addr 5: (word 3) bits 15-0 ... etc.  <a href="#a86fce22fd026c7cbbb4c3e524a359076">More...</a><br /></td></tr>
<tr class="separator:a86fce22fd026c7cbbb4c3e524a359076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ec44e1c4a8fdd1050a704b7b8a4a8a"><td class="memItemLeft" align="right" valign="top">Module: $flash.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flash_8asm.html#a41ec44e1c4a8fdd1050a704b7b8a4a8a">get_file_address</a> </td></tr>
<tr class="memdesc:a41ec44e1c4a8fdd1050a704b7b8a4a8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a request to the firmware to obtain the flash address of a file from the filesystem given it's VM file handle.  <a href="#a41ec44e1c4a8fdd1050a704b7b8a4a8a">More...</a><br /></td></tr>
<tr class="separator:a41ec44e1c4a8fdd1050a704b7b8a4a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4caf86c774e3e754d1cc3dbc9c71d3ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4caf86c774e3e754d1cc3dbc9c71d3ed"></a>
Module: $flash.<a class="el" href="flash_8asm.html#a41ec44e1c4a8fdd1050a704b7b8a4a8a">get_file_address</a>&#160;</td><td class="memItemRight" valign="bottom"><b>message_handler</b> </td></tr>
<tr class="separator:a4caf86c774e3e754d1cc3dbc9c71d3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This library provides an API to aid accessing data from the onchip flash memory from kalimba. Access to flash using BC3-MM is quite slow, it takes approx 2us (64 DSP clock cycles) per word. Using BC5-MM it is faster, but the access time still depends on the speed of the flash part used and the MCU's clock rate and workload. Typically with a 70ns flash the DSP will take 9 cycles (at 64MHz) to access a 16bit word from flash. </p>
<p><em>[SDK Folder]</em>/src/kalimba/core/flash.asm</p>
<p>Part of ADK_CSR867x.WIN. 4.4</p>
<h1>Flash access Library</h1>
<p>For BC5-MM this library also provides an API for initialising the hardware to allow execution from flash program memory (PM). Accessing flash program memory is slower than RAM, again depending on the flash part used and the MCU's clock rate and workload. Typically with a 70ns flash the DSP will take 17 cycles (at 64MHz) to access a 32bit instruction word from flash. There is a 64 word direct-mapped cache that is used when accessing PM flash, and so if there is a cache hit the access time is just a single clock cycle (same as accessing PM RAM).</p>
<p>For example use see the app in: apps/examples/kalimba_flash_access_example/</p>
<p>This library also presents an API for DSP applications to request the flash address of a file within the VM's read only file system. DSP applications request a file's flash address by calling '$flash.get_file_address' with the VM file handle. When the address has been retrieved the associated handler is called. The library uses structures to hold the information it requires for each request. Each structure should be of size $flash.get_file_address.STRUC_SIZE and contains the following fields: </p><pre class="fragment">       Name                                             Index
       $flash.get_file_address.NEXT_ENTRY_FIELD           0
       $flash.get_file_address.FILE_ID_FIELD              1
       $flash.get_file_address.HANDLER_ADDR_FIELD         2</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ae59f51797b4219dddd619dd3a8784402"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$flash copy_to_dm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the address of a 'flash segment' variable and its size this routine will copy the variable to a place in data memory ram. It will automatically switch flash pages as needed if the variable overlaps a flash page boundary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = address of variable in 'flash segment'</li>
<li>r1 = size of variable in 'flash segment'</li>
<li>r2 = starting address of 'flash segment'. This is filled out by firmware upon a KalimbaLoad call from the VM.</li>
<li>I0 = address to copy flash data to in DM</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>r0 = last word read from flash (useful if you're just reading 1 word)</li>
<li>I0 = end address of copied data + 1</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0, r1, r3, r4, r5, I1, I0, r10, DoLoop</dd>
</dl>

</div>
</div>
<a class="anchor" id="a86fce22fd026c7cbbb4c3e524a359076"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$flash copy_to_dm_24 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the address of a 'flash segment' variable and its size this routine will copy and unpack 24-bit data to a place in data memory ram. It will automatically switch flash pages as needed if the variable overlaps a flash page boundary. 24-bit data in flash is packed as follows: addr 0: (word 0) bits 23-8 addr 1: (word 0) bits 7-0 (word 1) bits 23-16 addr 2: (word 1) bits 15-0 addr 3: (word 2) bits 23-8 addr 4: (word 2) bits 7-0 (word 3) bits 23-16 addr 5: (word 3) bits 15-0 ... etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = address of variable in 'flash segment'</li>
<li>r1 = size of variable in RAM</li>
<li>r2 = starting address of 'flash segment'. This is filled out by firmware upon a KalimbaLoad call from the VM. (unchanged)</li>
<li>I0 = address to copy flash data to in DM</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>r0 = last word read from flash (useful if you're just reading 1 word)</li>
<li>I0 = end address of copied data + 1</li>
<li>r2 = (unchanged)</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0, r1, r3, r4, r5, r6, I1, I0, r10, DoLoop</dd>
</dl>

</div>
</div>
<a class="anchor" id="a73f8bd277fa9476a4cac9890e226d847"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$flash copy_to_dm_32_to_24 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the address of a 'flash segment' variable and its size this routine will copy the variable to a place in data memory ram. It will automatically switch flash pages as needed if the variable overlaps a flash page boundary. each 24-bit data, 0xABCDEF, is stored in 2 words in flash: </p>
<p>word 1: 0xABCD word 2: 0x&ndash;EF</p>
<p>where the 8 MSBits of the second word are ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = address of variable in 'flash segment'</li>
<li>r1 = size of variable in 'flash segment'</li>
<li>r2 = starting address of 'flash segment'. This is filled out by firmware upon a KalimbaLoad call from the VM.</li>
<li>I0 = address to copy flash data to in DM</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>r0 = last word read from flash (useful if you're just reading 1 word)</li>
<li>I0 = end address of copied data + 1</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0, r1, r3, r4, r5, I1, I0, r10, DoLoop</dd>
</dl>

</div>
</div>
<a class="anchor" id="a41ec44e1c4a8fdd1050a704b7b8a4a8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$flash get_file_address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a request to the firmware to obtain the flash address of a file from the filesystem given it's VM file handle. </p>
<p>INPUTS</p><ul>
<li>r1 = pointer to a structure that stores the 'get_file_address' handler structure, should be of length $flash.get_file_address.STRUC_SIZE</li>
<li>r2 = VM file handle number for which to retrieve the flash address</li>
<li>r3 = address of routine to call with the flash address</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0-6, r10, DoLoop</dd>
</dl>
<dl>
<dt><b>Notes:</b></dt>
<dd><p class="startdd">This is a request to the Firmware to retrieve the flash address of a file in the VM's read-only file system. This is not an instantaneous process. When you request a file's flash address the value is retrieved as a message and is sent to Kalimba. This is then forwarded on to your registered handler.</p>
<p>This library allows queuing of requests, the structure you supply is used in a linked list, consequently you cannot use the same structure until it has been freed from the list by the library. When the handler is called the structure will have already been freed so you may use it to request another read at that point.</p>
<p class="enddd"></p>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a523451630caac7174f478b959999e1be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$flash init_dmconst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>On a BC7 initialises flash data to be mapped into windows 2 and 3. 24-bit data (corresponding to DMCONST) is mapped into window 3, while 16-bit data is mapped into window 2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0</dd>
</dl>

</div>
</div>
<a class="anchor" id="ad446219a7776a8cbf823a64ccdb7450d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$flash init_pm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialises the PM_FLASH segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0</dd>
</dl>

</div>
</div>
<a class="anchor" id="a6f94e501a439af88ef44c87a515273a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$flash map_page_into_dm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the address of a 'flash segment' variable this routine will map in the appropriate flash page required and return a pointer to the DM2 flash window to access it. </p>
<p>The function also assumes that the size of the copy you wish to make from the flash page is passed in r1. If r1 is greater than the flash page size it will be set to the flash page size. If you don't require this behaviour, any value can be passed in r1 and the result can be ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = address of variable in 'flash segment'</li>
<li>r1 = optional size of variable in 'flash segment'</li>
<li>r2 = starting address of 'flash segment'. This is filled out by firmware upon a KalimbaLoad call from the VM.</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>r0 = an address in the DM2 flash window to read the variable from</li>
<li>r1 = an adjusted value of the size so that reads are kept within a single flash page</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r3</dd>
</dl>
<dl>
<dt><b>Notes:</b></dt>
<dd><p class="startdd">For BC5-MM we use FLASHWIN3 for these mappings</p>
<p class="enddd"></p>
</dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 3 2018 03:05:07 for Kalimba DSP Reference Guide by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
