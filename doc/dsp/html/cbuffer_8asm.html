<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Kalimba DSP Reference Guide: core/cbuffer.asm File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Kalimba DSP Reference Guide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_4270bfced15e0e73154b13468c7c9ad9.html">core</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">cbuffer.asm File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This library provides an API for dealing with buffers in Kalimba memory (which are called cbuffers) and the MMU ports which stream data between the Bluecore subsystem and the Kalimba.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af080f56f92d9a6c3eb0bd110a82fb9cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af080f56f92d9a6c3eb0bd110a82fb9cf"></a>
Module: $cbuffer.&#160;</td><td class="memItemRight" valign="bottom"><b>initialise</b> </td></tr>
<tr class="separator:af080f56f92d9a6c3eb0bd110a82fb9cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94dbb74ca1d6dc79d22d5bfcc527acba"><td class="memItemLeft" align="right" valign="top">Module: $cbuffer.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbuffer_8asm.html#a94dbb74ca1d6dc79d22d5bfcc527acba">is_it_enabled</a> </td></tr>
<tr class="memdesc:a94dbb74ca1d6dc79d22d5bfcc527acba"><td class="mdescLeft">&#160;</td><td class="mdescRight">See if a cbuffer/port is enabled/valid.  <a href="#a94dbb74ca1d6dc79d22d5bfcc527acba">More...</a><br /></td></tr>
<tr class="separator:a94dbb74ca1d6dc79d22d5bfcc527acba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a344496a254720c2a8c657361a5c8d8fd"><td class="memItemLeft" align="right" valign="top">Module: $cbuffer.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbuffer_8asm.html#a344496a254720c2a8c657361a5c8d8fd">get_read_address_and_size</a> </td></tr>
<tr class="memdesc:a344496a254720c2a8c657361a5c8d8fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a read address and size for a cbuffer/port so that it can read in a generic way.  <a href="#a344496a254720c2a8c657361a5c8d8fd">More...</a><br /></td></tr>
<tr class="separator:a344496a254720c2a8c657361a5c8d8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b824090fdc8b15a20716df767326035"><td class="memItemLeft" align="right" valign="top">Module: $cbuffer.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbuffer_8asm.html#a2b824090fdc8b15a20716df767326035">get_read_address_and_size_and_start_address</a> </td></tr>
<tr class="memdesc:a2b824090fdc8b15a20716df767326035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a read address and size for a cbuffer/port so that it can read in a generic way.  <a href="#a2b824090fdc8b15a20716df767326035">More...</a><br /></td></tr>
<tr class="separator:a2b824090fdc8b15a20716df767326035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6ceef8fbe843f0858eed176229e0f6"><td class="memItemLeft" align="right" valign="top">Module: $cbuffer.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbuffer_8asm.html#a8a6ceef8fbe843f0858eed176229e0f6">get_write_address_and_size_and_start_address</a> </td></tr>
<tr class="memdesc:a8a6ceef8fbe843f0858eed176229e0f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the write address and size for a cbuffer/port so that it can written in a generic way.  <a href="#a8a6ceef8fbe843f0858eed176229e0f6">More...</a><br /></td></tr>
<tr class="separator:a8a6ceef8fbe843f0858eed176229e0f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b4bbeddfe59d70ab9a7da9c6fb6d6e"><td class="memItemLeft" align="right" valign="top">Module: $frmbuffer.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbuffer_8asm.html#af0b4bbeddfe59d70ab9a7da9c6fb6d6e">get_buffer</a> </td></tr>
<tr class="memdesc:af0b4bbeddfe59d70ab9a7da9c6fb6d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get frame buffer frame size, ptr,length, and base address.  <a href="#af0b4bbeddfe59d70ab9a7da9c6fb6d6e">More...</a><br /></td></tr>
<tr class="separator:af0b4bbeddfe59d70ab9a7da9c6fb6d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc042bbbf6b2f1fff6c774b831d4dddc"><td class="memItemLeft" align="right" valign="top">Module: $frmbuffer.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbuffer_8asm.html#abc042bbbf6b2f1fff6c774b831d4dddc">set_frame_size</a> </td></tr>
<tr class="memdesc:abc042bbbf6b2f1fff6c774b831d4dddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set frame buffer's frame size.  <a href="#abc042bbbf6b2f1fff6c774b831d4dddc">More...</a><br /></td></tr>
<tr class="separator:abc042bbbf6b2f1fff6c774b831d4dddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3ea259f41f4ec46cf77ee9bee6b8f6"><td class="memItemLeft" align="right" valign="top">Module: $frmbuffer.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbuffer_8asm.html#a2a3ea259f41f4ec46cf77ee9bee6b8f6">set_frame_address</a> </td></tr>
<tr class="memdesc:a2a3ea259f41f4ec46cf77ee9bee6b8f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set frame buffer's frame address.  <a href="#a2a3ea259f41f4ec46cf77ee9bee6b8f6">More...</a><br /></td></tr>
<tr class="separator:a2a3ea259f41f4ec46cf77ee9bee6b8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0509b67789fcc2fba0a962201198f58"><td class="memItemLeft" align="right" valign="top">Module: $cbuffer.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbuffer_8asm.html#af0509b67789fcc2fba0a962201198f58">get_write_address_and_size</a> </td></tr>
<tr class="memdesc:af0509b67789fcc2fba0a962201198f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the write address and size for a cbuffer/port so that it can written in a generic way.  <a href="#af0509b67789fcc2fba0a962201198f58">More...</a><br /></td></tr>
<tr class="separator:af0509b67789fcc2fba0a962201198f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374c6e38b78cdad0ed9dc6c6581446e0"><td class="memItemLeft" align="right" valign="top">Module: $cbuffer.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbuffer_8asm.html#a374c6e38b78cdad0ed9dc6c6581446e0">set_read_address</a> </td></tr>
<tr class="memdesc:a374c6e38b78cdad0ed9dc6c6581446e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the read address for a cbuffer/port.  <a href="#a374c6e38b78cdad0ed9dc6c6581446e0">More...</a><br /></td></tr>
<tr class="separator:a374c6e38b78cdad0ed9dc6c6581446e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09af336e437076c119fb9a76c131d2ce"><td class="memItemLeft" align="right" valign="top">Module: $cbuffer.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbuffer_8asm.html#a09af336e437076c119fb9a76c131d2ce">set_write_address</a> </td></tr>
<tr class="memdesc:a09af336e437076c119fb9a76c131d2ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the write address for a cbuffer/port.  <a href="#a09af336e437076c119fb9a76c131d2ce">More...</a><br /></td></tr>
<tr class="separator:a09af336e437076c119fb9a76c131d2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b6b1ce03de2bfce95999855d43d5921"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b6b1ce03de2bfce95999855d43d5921"></a>
Module: $cbuffer.&#160;</td><td class="memItemRight" valign="bottom"><b>calc_amount_space</b> </td></tr>
<tr class="separator:a4b6b1ce03de2bfce95999855d43d5921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70183baac3e9e1b20dc05bae639ba5b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70183baac3e9e1b20dc05bae639ba5b1"></a>
Module: $cbuffer.&#160;</td><td class="memItemRight" valign="bottom"><b>calc_amount_data</b> </td></tr>
<tr class="separator:a70183baac3e9e1b20dc05bae639ba5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3ef5a43f285e64f5215d9786f097b4"><td class="memItemLeft" align="right" valign="top">Module: $cbuffer.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbuffer_8asm.html#a7d3ef5a43f285e64f5215d9786f097b4">mmu_octets_to_samples</a> </td></tr>
<tr class="memdesc:a7d3ef5a43f285e64f5215d9786f097b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the number of octets (in a port) to samples (note: this depends on the port configuration.  <a href="#a7d3ef5a43f285e64f5215d9786f097b4">More...</a><br /></td></tr>
<tr class="separator:a7d3ef5a43f285e64f5215d9786f097b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe10ded68a5a494be3e230bccdf4f074"><td class="memItemLeft" align="right" valign="top">Module: $cbuffer.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbuffer_8asm.html#abe10ded68a5a494be3e230bccdf4f074">buffer_configure</a> </td></tr>
<tr class="memdesc:abe10ded68a5a494be3e230bccdf4f074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures a kalimba cbuffer for use.  <a href="#abe10ded68a5a494be3e230bccdf4f074">More...</a><br /></td></tr>
<tr class="separator:abe10ded68a5a494be3e230bccdf4f074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995d8a4d1dc53286db56376f67356403"><td class="memItemLeft" align="right" valign="top">Module: $cbuffer.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbuffer_8asm.html#a995d8a4d1dc53286db56376f67356403">configure_port_message_handler</a> </td></tr>
<tr class="memdesc:a995d8a4d1dc53286db56376f67356403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Message handler for $MESSAGE_CONFIGURE_PORT message.  <a href="#a995d8a4d1dc53286db56376f67356403">More...</a><br /></td></tr>
<tr class="separator:a995d8a4d1dc53286db56376f67356403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e842ba11a337100382bfaec3a2b3866"><td class="memItemLeft" align="right" valign="top">Module: $cbuffer.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbuffer_8asm.html#a7e842ba11a337100382bfaec3a2b3866">force_mmu_set</a> </td></tr>
<tr class="memdesc:a7e842ba11a337100382bfaec3a2b3866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the MMU offsets.  <a href="#a7e842ba11a337100382bfaec3a2b3866">More...</a><br /></td></tr>
<tr class="separator:a7e842ba11a337100382bfaec3a2b3866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e4a9f7aa5cb106ad751e0618042849"><td class="memItemLeft" align="right" valign="top">Module: $cbuffer.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbuffer_8asm.html#a74e4a9f7aa5cb106ad751e0618042849">empty_buffer</a> </td></tr>
<tr class="memdesc:a74e4a9f7aa5cb106ad751e0618042849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empties the supplied port or cbuffer.  <a href="#a74e4a9f7aa5cb106ad751e0618042849">More...</a><br /></td></tr>
<tr class="separator:a74e4a9f7aa5cb106ad751e0618042849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1d3cc6054271be501fbddca34fe773"><td class="memItemLeft" align="right" valign="top">Module: $cbuffer.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbuffer_8asm.html#aaa1d3cc6054271be501fbddca34fe773">fill_buffer</a> </td></tr>
<tr class="memdesc:aaa1d3cc6054271be501fbddca34fe773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a port or cbuffer with a supplied value.  <a href="#aaa1d3cc6054271be501fbddca34fe773">More...</a><br /></td></tr>
<tr class="separator:aaa1d3cc6054271be501fbddca34fe773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f600a469dc63a7d7786bcbb9742852"><td class="memItemLeft" align="right" valign="top">Module: $cbuffer.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbuffer_8asm.html#a51f600a469dc63a7d7786bcbb9742852">advance_read_ptr</a> </td></tr>
<tr class="memdesc:a51f600a469dc63a7d7786bcbb9742852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advances read pointer of a cbuffer by a supplied value.  <a href="#a51f600a469dc63a7d7786bcbb9742852">More...</a><br /></td></tr>
<tr class="separator:a51f600a469dc63a7d7786bcbb9742852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87449a1188750d8dee62e232d376ee9b"><td class="memItemLeft" align="right" valign="top">Module: $cbuffer.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbuffer_8asm.html#a87449a1188750d8dee62e232d376ee9b">advance_write_ptr</a> </td></tr>
<tr class="memdesc:a87449a1188750d8dee62e232d376ee9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advances write pointer of a cbuffer by a supplied value.  <a href="#a87449a1188750d8dee62e232d376ee9b">More...</a><br /></td></tr>
<tr class="separator:a87449a1188750d8dee62e232d376ee9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae36d095ce43c50806c0c878a115d95c"><td class="memItemLeft" align="right" valign="top">Module: $cbuffer.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbuffer_8asm.html#aae36d095ce43c50806c0c878a115d95c">write_word</a> </td></tr>
<tr class="memdesc:aae36d095ce43c50806c0c878a115d95c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes 1 word to cbuffer.  <a href="#aae36d095ce43c50806c0c878a115d95c">More...</a><br /></td></tr>
<tr class="separator:aae36d095ce43c50806c0c878a115d95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22c54b2cd0a2e3eb4a68dfb2ff6af1f"><td class="memItemLeft" align="right" valign="top">Module: $cbuffer.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbuffer_8asm.html#af22c54b2cd0a2e3eb4a68dfb2ff6af1f">read_word</a> </td></tr>
<tr class="memdesc:af22c54b2cd0a2e3eb4a68dfb2ff6af1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 1 word from cbuffer.  <a href="#af22c54b2cd0a2e3eb4a68dfb2ff6af1f">More...</a><br /></td></tr>
<tr class="separator:af22c54b2cd0a2e3eb4a68dfb2ff6af1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aeab67192f2119f3b629ce1877d3dbf"><td class="memItemLeft" align="right" valign="top">Module: $cbuffer.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbuffer_8asm.html#a7aeab67192f2119f3b629ce1877d3dbf">peek_word_at_offset</a> </td></tr>
<tr class="memdesc:a7aeab67192f2119f3b629ce1877d3dbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 1 word from cbuffer at offset from read address without changing read address.  <a href="#a7aeab67192f2119f3b629ce1877d3dbf">More...</a><br /></td></tr>
<tr class="separator:a7aeab67192f2119f3b629ce1877d3dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a761a7661102e268e00f66766cbbf21ba"><td class="memItemLeft" align="right" valign="top">Module: $cbuffer.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbuffer_8asm.html#a761a7661102e268e00f66766cbbf21ba">update_word_at_offset</a> </td></tr>
<tr class="memdesc:a761a7661102e268e00f66766cbbf21ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates 1 word in cbuffer at offset from read address without changing read address.  <a href="#a761a7661102e268e00f66766cbbf21ba">More...</a><br /></td></tr>
<tr class="separator:a761a7661102e268e00f66766cbbf21ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0650a23f0c52b8c424915cdfe8f60f58"><td class="memItemLeft" align="right" valign="top">Module: $cbuffer.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbuffer_8asm.html#a0650a23f0c52b8c424915cdfe8f60f58">sync_write</a> </td></tr>
<tr class="memdesc:a0650a23f0c52b8c424915cdfe8f60f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronise write address of secondary cbuffers to primary cbuffer.  <a href="#a0650a23f0c52b8c424915cdfe8f60f58">More...</a><br /></td></tr>
<tr class="separator:a0650a23f0c52b8c424915cdfe8f60f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab81f360e8fcc19a0df8ab79bc2f1131c"><td class="memItemLeft" align="right" valign="top">Module: $cbuffer.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbuffer_8asm.html#ab81f360e8fcc19a0df8ab79bc2f1131c">sync_write_from_read</a> </td></tr>
<tr class="memdesc:ab81f360e8fcc19a0df8ab79bc2f1131c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronise write address of secondary cbuffers to primary cbuffer read address.  <a href="#ab81f360e8fcc19a0df8ab79bc2f1131c">More...</a><br /></td></tr>
<tr class="separator:ab81f360e8fcc19a0df8ab79bc2f1131c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4398a7de8daa6a6ea9c7df9a9b08bb0a"><td class="memItemLeft" align="right" valign="top">Module: $cbuffer.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbuffer_8asm.html#a4398a7de8daa6a6ea9c7df9a9b08bb0a">sync_read</a> </td></tr>
<tr class="memdesc:a4398a7de8daa6a6ea9c7df9a9b08bb0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronise read address of primary cbuffer to secondary cbuffers. The read address of the primary cbuffer will be set to the read address of the secondary cbuffer which is the furthest behind the primary cbuffer write address.  <a href="#a4398a7de8daa6a6ea9c7df9a9b08bb0a">More...</a><br /></td></tr>
<tr class="separator:a4398a7de8daa6a6ea9c7df9a9b08bb0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48b06f5e668dec994a86e596dd781cb"><td class="memItemLeft" align="right" valign="top">Module: $cbuffer.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbuffer_8asm.html#ad48b06f5e668dec994a86e596dd781cb">write_block</a> </td></tr>
<tr class="memdesc:ad48b06f5e668dec994a86e596dd781cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a block of data to a cbuffer Only works on cbuffers.  <a href="#ad48b06f5e668dec994a86e596dd781cb">More...</a><br /></td></tr>
<tr class="separator:ad48b06f5e668dec994a86e596dd781cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc1aba5f0689edf01b0e488573c56a0"><td class="memItemLeft" align="right" valign="top">Module: $cbuffer.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbuffer_8asm.html#aefc1aba5f0689edf01b0e488573c56a0">write_block_from_stack</a> </td></tr>
<tr class="memdesc:aefc1aba5f0689edf01b0e488573c56a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data from the stack and writes to cbuffer Only works on cbuffers.  <a href="#aefc1aba5f0689edf01b0e488573c56a0">More...</a><br /></td></tr>
<tr class="separator:aefc1aba5f0689edf01b0e488573c56a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f84ec65bf9f2f9b44f0f06a12c7cc5"><td class="memItemLeft" align="right" valign="top">Module: $cbuffer.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbuffer_8asm.html#ae5f84ec65bf9f2f9b44f0f06a12c7cc5">read_block</a> </td></tr>
<tr class="memdesc:ae5f84ec65bf9f2f9b44f0f06a12c7cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from a cbuffer into a block of memory Only works on cbuffers.  <a href="#ae5f84ec65bf9f2f9b44f0f06a12c7cc5">More...</a><br /></td></tr>
<tr class="separator:ae5f84ec65bf9f2f9b44f0f06a12c7cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad21cda5f8660bd6fc9cc96190f6ced79"><td class="memItemLeft" align="right" valign="top">Module: $cbuffer.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbuffer_8asm.html#ad21cda5f8660bd6fc9cc96190f6ced79">peek_block</a> </td></tr>
<tr class="memdesc:ad21cda5f8660bd6fc9cc96190f6ced79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from a cbuffer into a block of memory The read pointer is not updated after the read Only works on cbuffers.  <a href="#ad21cda5f8660bd6fc9cc96190f6ced79">More...</a><br /></td></tr>
<tr class="separator:ad21cda5f8660bd6fc9cc96190f6ced79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0694bc9b4a2248a7bd509c72c67fee6c"><td class="memItemLeft" align="right" valign="top">Module: $cbuffer.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbuffer_8asm.html#a0694bc9b4a2248a7bd509c72c67fee6c">move_pack_16</a> </td></tr>
<tr class="memdesc:a0694bc9b4a2248a7bd509c72c67fee6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move data from one cbuffer at 8 bits per word to another cbuffer as 16 bits per word.  <a href="#a0694bc9b4a2248a7bd509c72c67fee6c">More...</a><br /></td></tr>
<tr class="separator:a0694bc9b4a2248a7bd509c72c67fee6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095c87f18b296c4019db0530824d1ea7"><td class="memItemLeft" align="right" valign="top">Module: $cbuffer.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbuffer_8asm.html#a095c87f18b296c4019db0530824d1ea7">diff_write</a> </td></tr>
<tr class="memdesc:a095c87f18b296c4019db0530824d1ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the difference in the number of words written from 'before' to 'after'. Assumes the before and after cbuffer strucs are the same size.  <a href="#a095c87f18b296c4019db0530824d1ea7">More...</a><br /></td></tr>
<tr class="separator:a095c87f18b296c4019db0530824d1ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c1c82c9ef143241ae4c8be7d31c840"><td class="memItemLeft" align="right" valign="top">Module: $cbuffer.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbuffer_8asm.html#af4c1c82c9ef143241ae4c8be7d31c840">check_dmb_read_port</a> </td></tr>
<tr class="memdesc:af4c1c82c9ef143241ae4c8be7d31c840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check DMB port for more metadata. Copies metadata into cbuffer associated with MMU port. If no cbuffer metadata is thrown away.  <a href="#af4c1c82c9ef143241ae4c8be7d31c840">More...</a><br /></td></tr>
<tr class="separator:af4c1c82c9ef143241ae4c8be7d31c840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3cf83a251288aac89edc5271896e5e6"><td class="memItemLeft" align="right" valign="top">Module: $cbuffer.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbuffer_8asm.html#ae3cf83a251288aac89edc5271896e5e6">update_dmb_write_port</a> </td></tr>
<tr class="memdesc:ae3cf83a251288aac89edc5271896e5e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to write more metadata to DMB port.  <a href="#ae3cf83a251288aac89edc5271896e5e6">More...</a><br /></td></tr>
<tr class="separator:ae3cf83a251288aac89edc5271896e5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31299fd63cea1ec2e8bad9f2c4df9ec8"><td class="memItemLeft" align="right" valign="top">Module: $cbuffer.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbuffer_8asm.html#a31299fd63cea1ec2e8bad9f2c4df9ec8">register_metadata_cbuffer</a> </td></tr>
<tr class="memdesc:a31299fd63cea1ec2e8bad9f2c4df9ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a cbuffer for MMU port metadata.  <a href="#a31299fd63cea1ec2e8bad9f2c4df9ec8">More...</a><br /></td></tr>
<tr class="separator:a31299fd63cea1ec2e8bad9f2c4df9ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae9391d754cca8120b109422c74bb0838"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><b>r0</b></td></tr>
<tr class="separator:ae9391d754cca8120b109422c74bb0838"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This library provides an API for dealing with buffers in Kalimba memory (which are called cbuffers) and the MMU ports which stream data between the Bluecore subsystem and the Kalimba. </p>
<p><em>[SDK Folder]</em>/src/kalimba/core/cbuffer.asm</p>
<p>Part of ADK_CSR867x.WIN. 4.4</p>
<h1>Connection Buffer Library</h1>
<p>An interface is of use since the hardware buffers are a fixed size that is often too small to take a 'frame' of codec data. Also, data jitter is removed through the use of larger software based buffers.</p>
<p>Once a cbuffer has been initialised, it may be referenced using its buffer structure alone; the size, read and write pointers are all stored and used appropriately.</p>
<p>This interface is potentially wasteful in memory since data is, effectively, buffered twice but for most real world applications, for example MP3 decoding, codecs produce data in large chunks that would need to be stored in a temporary buffer.</p>
<p>Libraries may be written that read or write data to/from a cbuffer and hence provide a standard interface. These cbuffers may then be connected (using a copying function) to a Kalimba port to transfer the data to the Bluecore subsystem. During this copying operation, operations such as bit width conversion, DC removal, volume adjustment, filtering and equalisation may be performed using the CBOPS library routines.</p>
<p>For example, a generic codec decoder library may be written which has 1 cbuffer (the compressed input stream) as input and two cbuffers (stereo audio streams) as outputs. These cbuffers may then be connected (using copying functions) to Kalimba ports, or perhaps through some other library such as an audio equaliser. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a51f600a469dc63a7d7786bcbb9742852"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$cbuffer advance_read_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advances read pointer of a cbuffer by a supplied value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = pointer to cbuffer struc</li>
<li>r10 = number by which read pointer would be advanced</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0, r1, I0, L0, M3</dd>
</dl>
<dl>
<dt><b>Notes:</b></dt>
<dd><p class="startdd">This routine advances the read pointer of the cbuffer by a supplied value</p>
<p class="enddd"></p>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a87449a1188750d8dee62e232d376ee9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$cbuffer advance_write_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advances write pointer of a cbuffer by a supplied value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = pointer to cbuffer struc</li>
<li>r10 = number by which write pointer should be advanced May be negative to achieve regression</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0, r1, I0, L0, M3</dd>
</dl>
<dl>
<dt><b>Notes:</b></dt>
<dd><p class="startdd">This routine advances the write pointer of the cbuffer by a supplied value</p>
<p class="enddd"></p>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="abe10ded68a5a494be3e230bccdf4f074"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$cbuffer buffer_configure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures a kalimba cbuffer for use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = cbuffer structure</li>
<li>r1 = read/write address (ie. initialised to be the same)</li>
<li>r2 = buffer size</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>none</dd>
</dl>

</div>
</div>
<a class="anchor" id="af4c1c82c9ef143241ae4c8be7d31c840"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$cbuffer check_dmb_read_port </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check DMB port for more metadata. Copies metadata into cbuffer associated with MMU port. If no cbuffer metadata is thrown away. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0, r1, r2 r3, r10, I0, L0, I4, L4</dd>
</dl>

</div>
</div>
<a class="anchor" id="a995d8a4d1dc53286db56376f67356403"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$cbuffer configure_port_message_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Message handler for $MESSAGE_CONFIGURE_PORT message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = message ID</li>
<li>r1 = message Data 0 (Port number 0-3 read port, 4-7 write port)</li>
<li>r2 = message Data 1 (Offset address pointer)</li>
<li>r3 = message Data 2 (Limit address pointer)</li>
<li>r4 = message Data 3 (Metadata flags)</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0, r1, r2</dd>
</dl>

</div>
</div>
<a class="anchor" id="a095c87f18b296c4019db0530824d1ea7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$cbuffer diff_write </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the difference in the number of words written from 'before' to 'after'. Assumes the before and after cbuffer strucs are the same size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = pointer to 'before' cbuffer struc</li>
<li>r1 = pointer to 'after' cbuffer struc</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>r0 = the number of words written from before to after</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0, r1, r2, r3</dd>
</dl>

</div>
</div>
<a class="anchor" id="a74e4a9f7aa5cb106ad751e0618042849"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$cbuffer empty_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Empties the supplied port or cbuffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = pointer to cbuffer structure (for cbuffers) or a port identifier (for ports)</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>If a cbuffer: r0, r1, r3</dd>
</dl>
<p>If a port : r0, r1, r2, r3, r4, r5, r6, r10, DoLoop</p>
<dl>
<dt><b>Notes:</b></dt>
<dd><p class="startdd">This routine empties a port or cbuffer. For cbuffers it simply moves the read pointer, for ports it must read the samples from the port.</p>
<p>Interrupts should be blocked before this call, unless you "own" the cbuffer read pointer.</p>
<p class="enddd"></p>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="aaa1d3cc6054271be501fbddca34fe773"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$cbuffer fill_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills a port or cbuffer with a supplied value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = pointer to cbuffer structure (for cbuffers) or a port identifier (for ports)</li>
<li>r1 = value to write into buffer/port</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>If a cbuffer: r0 - r4, r10, I0, L0, DoLoop</dd>
</dl>
<p>If a port : r0, r1, r2, r3, r4, r5, r6, r10, DoLoop</p>
<dl>
<dt><b>Notes:</b></dt>
<dd><p class="startdd">This routine fills a port or cbuffer with a supplied value.</p>
<p>Interrupts must be blocked during this call.</p>
<p class="enddd"></p>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a7e842ba11a337100382bfaec3a2b3866"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$cbuffer force_mmu_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the MMU offsets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>none</dd>
</dl>
<dl>
<dt><b>Notes:</b></dt>
<dd><p class="startdd">This forces an MMU buffer set.</p>
<p>Each MMU port has an offset which tracks how much data has been accessed from the port. The DSP uses this value to work out how much data/space is available in the port.</p>
<p>Kalimba can explicitly force an MMU buffer set. Consequently a local offset is not stored in the DSP and the cache will never be stale so long as you perform a set after reads and writes - i.e. call $cbuffer.set_read_address and $cbuffer.set_write_address.</p>
<p class="enddd"></p>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="af0b4bbeddfe59d70ab9a7da9c6fb6d6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$frmbuffer get_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get frame buffer frame size, ptr,length, and base address. </p>
<p>$frmbuffer.get_buffer_with_start_address</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = pointer to frame buffer structure</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>r0 = buffer address</li>
<li>r1 = buffer size</li>
<li>r2 = buffer start address &lt;base address="" variant&gt;=""&gt;</li>
<li>r3 = frame size</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r2 - (not base address variant)</dd>
</dl>
<dl>
<dt><b>Notes:</b></dt>
<dd><p class="startdd">Return the buffer start address in r2 if BASE_REGISTER_MODE</p>
<p class="enddd"></p>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a344496a254720c2a8c657361a5c8d8fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$cbuffer get_read_address_and_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a read address and size for a cbuffer/port so that it can read in a generic way. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = pointer to cbuffer structure (for cbuffers) or a port identifier (for ports)</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>r0 = read address</li>
<li>r1 = buffer size</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>none</dd>
</dl>
<dl>
<dt><b>Notes:</b></dt>
<dd><p class="startdd">If passed a pointer to a cbuffer structure then return the value of the current read address and size of the cbuffer. If passed a port identifier then return the read address for the port, and set the size always to 1.</p>
<p>After having read a block of data a call must be made to $cbuffer.set_read_address to actually update the read pointer accordingly. E.g. </p><pre class="fragment">      // get the read pointer for $my_cbuffer_struc
      r0 = $my_cbuffer_struc;
      call $cbuffer.get_read_address_and_size;
      I0 = r0;
      L0 = r1;

      // now read some data from it
      // NOTE: Should already have checked that there is enough data
      // in the buffer to be able to read these 10 locations, ie.
      // using $cbuffer.calc_amount_data.
      r10 = 10;
      r5 = 0;
      do sum_10_samples_loop;
         r1 = M[I0,1];
         r5 = r5 + r1;
      sum_10_samples_loop:
      ....

      // now update the stored pointers
      r0 = $my_cbuffer_struc;
      r1 = I0;
      call $cbuffer.set_read_address;</pre><p class="enddd"></p>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a2b824090fdc8b15a20716df767326035"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$cbuffer get_read_address_and_size_and_start_address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a read address and size for a cbuffer/port so that it can read in a generic way. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = pointer to cbuffer structure (for cbuffers)</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>r0 = read address</li>
<li>r1 = buffer size</li>
<li>r2 = buffer start address</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>none</dd>
</dl>
<dl>
<dt><b>Notes:</b></dt>
<dd><p class="startdd">If passed a pointer to a cbuffer structure then return the value of the current read address and size of the cbuffer.</p>
<p class="enddd"></p>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="af0509b67789fcc2fba0a962201198f58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$cbuffer get_write_address_and_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the write address and size for a cbuffer/port so that it can written in a generic way. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = pointer to cbuffer structure (for cbuffers) or a port identifier (for ports)</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>r0 = write address</li>
<li>r1 = buffer size</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>none</dd>
</dl>
<dl>
<dt><b>Notes:</b></dt>
<dd><p class="startdd">If passed a pointer to a cbuffer structure then return the value of the current write address and size of the cbuffer. If passed a port identifier then return the write address for the port, and set the size always to 1.</p>
<p class="enddd"></p>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a8a6ceef8fbe843f0858eed176229e0f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$cbuffer get_write_address_and_size_and_start_address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the write address and size for a cbuffer/port so that it can written in a generic way. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = pointer to cbuffer structure (for cbuffers) or a port identifier (for ports)</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>r0 = write address</li>
<li>r1 = buffer size</li>
<li>r2 = buffer start address</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>none</dd>
</dl>
<dl>
<dt><b>Notes:</b></dt>
<dd><p class="startdd">If passed a pointer to a cbuffer structure then return the value of the current write address and size of the cbuffer. If passed a port identifier then return the write address for the port, and set the size always to 1.</p>
<p class="enddd"></p>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a94dbb74ca1d6dc79d22d5bfcc527acba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$cbuffer is_it_enabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See if a cbuffer/port is enabled/valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = pointer to cbuffer structure (for cbuffers) or a port identifier (for ports)</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>Z flag set if the port/cbuffer isn't enabled/valid</li>
<li>Z flag cleared if the port/cbuffer is enabled/valid</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0</dd>
</dl>

</div>
</div>
<a class="anchor" id="a7d3ef5a43f285e64f5215d9786f097b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$cbuffer mmu_octets_to_samples </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the number of octets (in a port) to samples (note: this depends on the port configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r2 = Number of octets (e.g. size of port in octets)</li>
<li>r3 = Port ID/configuration</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>r2 = Number of samples</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>None</dd>
</dl>

</div>
</div>
<a class="anchor" id="a0694bc9b4a2248a7bd509c72c67fee6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$cbuffer move_pack_16 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move data from one cbuffer at 8 bits per word to another cbuffer as 16 bits per word. </p>
<ul>
<li>r0 = pointer to source cbuffer struc (8 bits per word)</li>
<li>r1 = pointer to destination cbuffer struc (16 bits per word)</li>
<li>r2 = number of bytes to copy</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r3,r4,r10</dd>
</dl>

</div>
</div>
<a class="anchor" id="ad21cda5f8660bd6fc9cc96190f6ced79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$cbuffer peek_block </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from a cbuffer into a block of memory The read pointer is not updated after the read Only works on cbuffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = pointer to cbuffer struct</li>
<li>r1 = pointer to block of data</li>
<li>r8 = length of data to copy</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r2, r10, I4, I0, L0</dd>
</dl>

</div>
</div>
<a class="anchor" id="a7aeab67192f2119f3b629ce1877d3dbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$cbuffer peek_word_at_offset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read 1 word from cbuffer at offset from read address without changing read address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = pointer to cbuffer struc</li>
<li>r1 = offset to read address</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>r1 = word read from cbuffer</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r2, I0, M0, L0</dd>
</dl>
<dl>
<dt><b>Notes:</b></dt>
<dd><p class="startdd">cbuffer is not checked to see if it is empty</p>
<p class="enddd"></p>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ae5f84ec65bf9f2f9b44f0f06a12c7cc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$cbuffer read_block </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from a cbuffer into a block of memory Only works on cbuffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = pointer to cbuffer struct</li>
<li>r1 = pointer to block of data</li>
<li>r8 = length of data to copy</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r2, r10, I4, I0, L0</dd>
</dl>

</div>
</div>
<a class="anchor" id="af22c54b2cd0a2e3eb4a68dfb2ff6af1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$cbuffer read_word </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read 1 word from cbuffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = pointer to cbuffer struc</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>r1 = word read from cbuffer</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r2, I0, L0</dd>
</dl>
<dl>
<dt><b>Notes:</b></dt>
<dd><p class="startdd">cbuffer is not checked to see if it is empty</p>
<p class="enddd"></p>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a31299fd63cea1ec2e8bad9f2c4df9ec8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$cbuffer register_metadata_cbuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a cbuffer for MMU port metadata. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = port</li>
<li>r1 = cbuffer</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0, r1</dd>
</dl>

</div>
</div>
<a class="anchor" id="a2a3ea259f41f4ec46cf77ee9bee6b8f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$frmbuffer set_frame_address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set frame buffer's frame address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = pointer to frame buffer structure</li>
<li>r1 = frame address</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><dl>
<dt><b>Trashed Registers:</b></dt>
<dd>none</dd>
</dl>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Notes:</b></dt>
<dd></dd>
</dl>

</div>
</div>
<a class="anchor" id="abc042bbbf6b2f1fff6c774b831d4dddc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$frmbuffer set_frame_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set frame buffer's frame size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = pointer to frame buffer structure</li>
<li>r3 = frame size</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><dl>
<dt><b>Trashed Registers:</b></dt>
<dd>none</dd>
</dl>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Notes:</b></dt>
<dd></dd>
</dl>

</div>
</div>
<a class="anchor" id="a374c6e38b78cdad0ed9dc6c6581446e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$cbuffer set_read_address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the read address for a cbuffer/port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = pointer to cbuffer structure (for cbuffers) or a port identifier (for ports)</li>
<li>r1 = read address</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>If a cbuffer: none</dd>
</dl>
<p>If a port: r0, r1, r2, r3, r4, r5, r6, r10, DoLoop</p>
<dl>
<dt><b>Notes:</b></dt>
<dd><p class="startdd">If passed a pointer to a cbuffer structure then set the value of the current read address of the cbuffer. If passed a port identifier then set the read offset for the port, and handle other maintainance tasks associated with ports.</p>
<p class="enddd"></p>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a09af336e437076c119fb9a76c131d2ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$cbuffer set_write_address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the write address for a cbuffer/port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = pointer to cbuffer structure (for cbuffers) or a port identifier (for ports)</li>
<li>r1 = write address</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>If a cbuffer: none</dd>
</dl>
<p>If a port: r0, r1, r2, r3, r4, r5, r6, r10, DoLoop</p>
<dl>
<dt><b>Notes:</b></dt>
<dd><p class="startdd">If passed a pointer to a cbuffer structure then set the value of the current write address of the cbuffer. If passed a port identifier then set the write offset for the port, and handle other maintainance tasks associated with ports.</p>
<p class="enddd"></p>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a4398a7de8daa6a6ea9c7df9a9b08bb0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$cbuffer sync_read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronise read address of primary cbuffer to secondary cbuffers. The read address of the primary cbuffer will be set to the read address of the secondary cbuffer which is the furthest behind the primary cbuffer write address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = pointer to NULL terminated array cbuffers</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>r0 - address after the NULL terminator</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r1-r4, r1, I0</dd>
</dl>

</div>
</div>
<a class="anchor" id="a0650a23f0c52b8c424915cdfe8f60f58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$cbuffer sync_write </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronise write address of secondary cbuffers to primary cbuffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = pointer to NULL terminated array cbuffers</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>r0 = address after NULL</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r1, I0</dd>
</dl>

</div>
</div>
<a class="anchor" id="ab81f360e8fcc19a0df8ab79bc2f1131c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$cbuffer sync_write_from_read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronise write address of secondary cbuffers to primary cbuffer read address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = pointer to NULL terminated array cbuffers</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>r0 = address after NULL</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r1, I0</dd>
</dl>

</div>
</div>
<a class="anchor" id="ae3cf83a251288aac89edc5271896e5e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$cbuffer update_dmb_write_port </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to write more metadata to DMB port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r3 - mask of mmu ports to check</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0, r1, r2, r3, r4, r5, r6, r10, I0, L0, I4, L4</dd>
</dl>

</div>
</div>
<a class="anchor" id="a761a7661102e268e00f66766cbbf21ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$cbuffer update_word_at_offset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates 1 word in cbuffer at offset from read address without changing read address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = pointer to cbuffer struc</li>
<li>r1 = offset to read address</li>
<li>r2 = new value for the word</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>None</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r2, r3, I0, M0, L0</dd>
</dl>
<dl>
<dt><b>Notes:</b></dt>
<dd><p class="startdd">cbuffer is not checked to see if it is empty</p>
<p class="enddd"></p>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ad48b06f5e668dec994a86e596dd781cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$cbuffer write_block </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a block of data to a cbuffer Only works on cbuffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = pointer to cbuffer struct</li>
<li>r1 = pointer to block of data</li>
<li>r8 = length of data to copy</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r1, r2, r10, I4, I0, L0</dd>
</dl>

</div>
</div>
<a class="anchor" id="aefc1aba5f0689edf01b0e488573c56a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$cbuffer write_block_from_stack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads data from the stack and writes to cbuffer Only works on cbuffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = pointer to cbuffer struct</li>
<li>r8 = length of data to copy</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r1, r10, I0, L0</dd>
</dl>

</div>
</div>
<a class="anchor" id="aae36d095ce43c50806c0c878a115d95c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$cbuffer write_word </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes 1 word to cbuffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = pointer to cbuffer struc</li>
<li>r1 = word to write to cbuffer</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r2, I0, L0</dd>
</dl>
<dl>
<dt><b>Notes:</b></dt>
<dd><p class="startdd">cbuffer is not checked to see if it is full</p>
<p class="enddd"></p>
</dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ae9391d754cca8120b109422c74bb0838"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">r0</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= pointer to source cbuffer struc (8 bits per word)</div>
<div class="line">   - r1 = pointer to destination cbuffer struc (24 bits per word)</div>
<div class="line">   - r2 = number of bytes to <a class="code" href="cbops_8asm.html#af85ed9b51ebc04a7bfe10264e04d70dd">copy</a></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">Module: $cbuffer..diff_read</div>
<div class="ttc" id="cbops_8asm_html_af85ed9b51ebc04a7bfe10264e04d70dd"><div class="ttname"><a href="cbops_8asm.html#af85ed9b51ebc04a7bfe10264e04d70dd">copy</a></div><div class="ttdeci">Module: $cbops.copy</div><div class="ttdoc">Copy available data from the input cbuffer/port to output cbuffer/port. The copying is done by callin...</div></div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 3 2018 03:05:07 for Kalimba DSP Reference Guide by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
