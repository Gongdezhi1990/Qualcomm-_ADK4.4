<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Kalimba DSP Reference Guide: cbops/operators/cbops_univ_mix_op.asm File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Kalimba DSP Reference Guide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_2e7bb94b659ebdb4d604e8a4d2bc22e0.html">cbops</a></li><li class="navelem"><a class="el" href="dir_ea60bc174a9f695c0dc189311fa15b02.html">operators</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cbops_univ_mix_op.asm File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This operator allows primary and secondary channels to be scaled, upsampled or downsampled, and then mixed. This currently assumes processing of stereo or mono data streams (but NOT a mixture of the two!).  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;cbops_univ_mix_op.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2c08c98977ac4ba260257576a492fa9c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c08c98977ac4ba260257576a492fa9c"></a>
Module: $cbops.univ_mix_op&#160;</td><td class="memItemRight" valign="bottom"><b>reset</b> </td></tr>
<tr class="separator:a2c08c98977ac4ba260257576a492fa9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4d212429bb3e11ad82484e38c658df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d4d212429bb3e11ad82484e38c658df"></a>
Module: $cbops.univ_mix_op&#160;</td><td class="memItemRight" valign="bottom"><b>amount_to_use</b> </td></tr>
<tr class="separator:a6d4d212429bb3e11ad82484e38c658df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2023eb29d1cd5a001b32d7c389763b"><td class="memItemLeft" align="right" valign="top">Module: $cbops.univ_mix_op&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbops__univ__mix__op_8asm.html#a9a2023eb29d1cd5a001b32d7c389763b">calc_output_samples_helper</a> </td></tr>
<tr class="memdesc:a9a2023eb29d1cd5a001b32d7c389763b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for amount_to_use.  <a href="#a9a2023eb29d1cd5a001b32d7c389763b">More...</a><br /></td></tr>
<tr class="separator:a9a2023eb29d1cd5a001b32d7c389763b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82fa039ee3ce54d6f0c437f2dfed4aa"><td class="memItemLeft" align="right" valign="top">Module: $cbops.univ_mix_op&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbops__univ__mix__op_8asm.html#aa82fa039ee3ce54d6f0c437f2dfed4aa">secondary_setup_helper</a> </td></tr>
<tr class="memdesc:aa82fa039ee3ce54d6f0c437f2dfed4aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for amount_to_use to set up the secondary channel.  <a href="#aa82fa039ee3ce54d6f0c437f2dfed4aa">More...</a><br /></td></tr>
<tr class="separator:aa82fa039ee3ce54d6f0c437f2dfed4aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8baff0a6f69a2ee3ee145438f4a54aa1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8baff0a6f69a2ee3ee145438f4a54aa1"></a>
Module: $cbops.univ_mix_op&#160;</td><td class="memItemRight" valign="bottom"><b>main</b> </td></tr>
<tr class="separator:a8baff0a6f69a2ee3ee145438f4a54aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264cb63c1aea5d49eddd402bce854f63"><td class="memItemLeft" align="right" valign="top">Module: $cbops.univ_mix_op&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbops__univ__mix__op_8asm.html#a264cb63c1aea5d49eddd402bce854f63">main_helper</a> </td></tr>
<tr class="memdesc:a264cb63c1aea5d49eddd402bce854f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main function helper to setup and call the upsampler function.  <a href="#a264cb63c1aea5d49eddd402bce854f63">More...</a><br /></td></tr>
<tr class="separator:a264cb63c1aea5d49eddd402bce854f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21a466f45cad96449c705e449457974"><td class="memItemLeft" align="right" valign="top">Module: $cbops.univ_mix_op&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbops__univ__mix__op_8asm.html#af21a466f45cad96449c705e449457974">secondary_cbuffer_pointer_update</a> </td></tr>
<tr class="memdesc:af21a466f45cad96449c705e449457974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to update the secondary cbuffer input pointers after buffer writing. This only needs to be called if both the primary and secondary channels are active. If the secondary channel ONLY is active then it is handled in the conventional way by cbops.copy. Also note that the output cbuffers will be updated by the primary channel (cbops.copy) so these do not need updating.  <a href="#af21a466f45cad96449c705e449457974">More...</a><br /></td></tr>
<tr class="separator:af21a466f45cad96449c705e449457974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5840928c275231ad40006c7c60614ff8"><td class="memItemLeft" align="right" valign="top">Module: $cbops.univ_mix_op&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbops__univ__mix__op_8asm.html#a5840928c275231ad40006c7c60614ff8">init_upsampler</a> </td></tr>
<tr class="memdesc:a5840928c275231ad40006c7c60614ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize routine for the upsampler. Set up defaults which give unity gain and no upsampling.  <a href="#a5840928c275231ad40006c7c60614ff8">More...</a><br /></td></tr>
<tr class="separator:a5840928c275231ad40006c7c60614ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b4e02f7923ea7d36eedb6a1dbd0f3b"><td class="memItemLeft" align="right" valign="top">Module: $cbops.univ_mix_op&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbops__univ__mix__op_8asm.html#a52b4e02f7923ea7d36eedb6a1dbd0f3b">ramp_volume</a> </td></tr>
<tr class="memdesc:a52b4e02f7923ea7d36eedb6a1dbd0f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volume is ramped to desired value from current value. If the callback function pointer is not NULL, the address is called on completion of the volume ramp.  <a href="#a52b4e02f7923ea7d36eedb6a1dbd0f3b">More...</a><br /></td></tr>
<tr class="separator:a52b4e02f7923ea7d36eedb6a1dbd0f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24a6b1be9d15a8e829c0279d578e9e4"><td class="memItemLeft" align="right" valign="top">Module: $cbops.univ_mix_op&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cbops__univ__mix__op_8asm.html#ae24a6b1be9d15a8e829c0279d578e9e4">upsampler</a> </td></tr>
<tr class="memdesc:ae24a6b1be9d15a8e829c0279d578e9e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upsample data - input data is upsampled and filtered to produce output data at an integer multiple of the input rate. The ratios supported are dependent on the defined filter sets (currently these support ratios of 2, 4 and 6). Ratios which are not an integer multiple are also supported using linear interpolation between samples delivered by the upsampling process (e.g. can produce samples at a 44.1kHz sampling rate from samples at a 48kHz sampling rate.  <a href="#ae24a6b1be9d15a8e829c0279d578e9e4">More...</a><br /></td></tr>
<tr class="separator:ae24a6b1be9d15a8e829c0279d578e9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This operator allows primary and secondary channels to be scaled, upsampled or downsampled, and then mixed. This currently assumes processing of stereo or mono data streams (but NOT a mixture of the two!). </p>
<p><em>[SDK Folder]</em>/src/kalimba/operators/cbops_univ_mix_op.asm</p>
<p>Part of ADK_CSR867x.WIN. 4.4</p>
<h1>Universal mixer operator</h1>
<p>The primary and secondary channel can be operated alone or both together. The gain/attenuation of each channel can be set independently. Each channel can be upsampled (using an integer upsampling factor) followed by linear interpolation. Example FIR filters are defined to support integer upsampling by factors of 2, 4, and 6. The interpolation stage allows the operator to also deliver output sampling rates which are not a multiple of the input sampling rate.</p>
<p>Downsampling can be achieved by choosing an appropriate FIR response and using a phaseStep value to select the output samples (or those used to interpolate the output sample. When performing downsampling by an integer factor FIR responses should not be scaled.</p>
<p>The operator is called from cbops.copy. This provides either the primary or the secondary input channel. When both channels are active the secondary channel is handled internally to the operator. This approach is necessary because the cbops.copy is not designed to handle multiple input sources at different sampling rates.</p>
<p>The fundamental volume of each channel is controlled by two values (a fractional gain factor and a shift value). These allow flexible control of the channel gains for gain&gt;1 and gain&lt;1 whilst maintaining the dynamic range. In addition, there is a volume ramping function which ramps the volume on a channel to a pre-determined level when the target gain is changed. This is intended to allow the gain of the channels to be varied gracefully as mixing is enabled and disabled (i.e. gain is is reduced when mixing to prevent overflows).</p>
<h2>Overview of the way the mixer handles the I/O within the cbops framework: </h2>
<p>The primary channel is always handled using the standard cbops processing. The secondary channel when used in conjunction with the primary (i.e. when mixing) is handled internally to the operator but this is done in a way which mimics the standard cbops.copy operation. If the secondary is used on its own then it uses the standard cbops processing. The standard cbops handling of primary and secondary can not be used in general because of the differing amounts of input data consumed due to the essentially arbitrary sampling rates. The way the univ_mixer operator is controlled in the framework is basically governed by the available samples in each of the input buffers and the space in the output buffer. Crucially, the system is configured such that the primary and secondary channel outputs have the same rate and so can be easily mixed into a single output buffer. Mono/stereo operation is very similar with stereo being essentially two instances of a mono channel(in the same cbops chain).</p>
<h2>Procedure used to determine how much data is processed on each call to cbops.copy: </h2>
<p>1/ Determine the number of available i/p samples for prim and sec channels 2/ Determine the output buffer space in samples (only one buffer for both channels here) 3/ Calculate the number of o/p samples that would be generated for prim and sec based on 1/ and the channel sampling rate ratio (reduce by a small delta to overcome precision effects) 4/ Take the smaller of the prim and sec o/p sample count 5/ Limit the o/p sample count so it doesn?t exceed the available o/p buffer space from 2/ 6/ Process the data from prim until the number of o/p samples from 5/ has been produced 7/ Process the data from sec until the number of o/p samples from 5/ has been produced (these are mixed in-place in the output buffer) 8/ Set the number of input samples consumed by the prim channel 9/ Set the number of input samples consumed by the sec channel 10/ Set the number of output samples produced</p>
<p>These calculations are distributed amongst the cbops.copy, cbops.univ_mix_op.amount_to_use, and the main operator process function.</p>
<p>The amount of input data the main cbops operator function processes from each channel is determined only after the generation of a specified number of output samples and purely by the amount consumed from that channel. Under the current scheme of things this means that it is not possible to add a cbops.operator into the chain before the mixer since the amount of data it must process is not known before the mixer processing has completed. However, the amount of data that the mixer will produce is known prior to the mixer processing. It would therefore be possible to add a cbops.operator following the univ_mixer operator in the chain but it would need to employ a special "amount_to_use" function to determine how much data was output from the mixer operator. </p><hr/>
<p>When using the operator a structure with the following data elements is used:</p>
<p>$cbops.univ_mix_op.INPUT_START_INDEX_FIELD = Index of the first input buffer $cbops.univ_mix_op.OUTPUT_START_INDEX_FIELD = Index of the first output buffer $cbops.univ_mix_op.MIXER_PRIMARY_COPY_STRUCT_ADDR_FIELD = Pointer back to the primary mixer copy structure $cbops.univ_mix_op.MIXER_SECONDARY_COPY_STRUCT_ADDR_FIELD = Pointer back to the secondary mixer copy structure $cbops.univ_mix_op.COMMON_PARAM_STRUCT_ADDR_FIELD = Pointer to a structure of common mixer parameters $cbops.univ_mix_op.PRIMARY_UPSAMPLER_STRUCT_ADDR_FIELD = Pointer to the primary channel upsampler structure $cbops.univ_mix_op.SECONDARY_UPSAMPLER_STRUCT_ADDR_FIELD = Pointer to the secondary channel upsampler structure $cbops.univ_mix_op.OUTPUT_UPSAMPLER_STRUCT_ADDR_FIELD = Pointer to the output channel upsampler structure </p><hr/>
<p> The gain/upsampling/interpolation for each channel is defined by a structure with the following elements: </p><hr/>
 <h2>Upsampler parameter structure fields (left &amp; right channels may be shared) </h2>
<p>$cbops.univ_mix_op.params.INPUT_GAIN_FACTOR_FIELD = Gain factor(fractional multiply) $cbops.univ_mix_op.params.INPUT_GAIN_SHIFT_FIELD = Gain shift (integer n, giving 2^n gain value)</p>
<p>$cbops.univ_mix_op.params.RAMP_GAIN_WHEN_MIXING_FIELD = Desired gain when mixing (fractional, 0.0-1.0) for the mixing volume adjustment $cbops.univ_mix_op.params.TARGET_RAMP_GAIN_ADJUST_FIELD = Target gain (fractional, 0.0-1.0) for the mixing volume adjustment $cbops.univ_mix_op.params.NUM_RAMP_SAMPLES_FIELD = Number of input samples between volume steps in the volume ramp $cbops.univ_mix_op.params.RAMP_STEP_SHIFT_FIELD = Shift (negative integer) used for each volume step adjustment $cbops.univ_mix_op.params.RAMP_DELTA_FIELD = Additional (fractional) value used for each volume step adjustment</p>
<p>$cbops.univ_mix_op.params.UPSAMPLING_FACTOR_FIELD = Integer upsampling factor $cbops.univ_mix_op.params.INPUT_RATE_FIELD = Input sampling rate $cbops.univ_mix_op.params.INVERSE_INPUT_RATE_FIELD = 1/(input sampling rate) $cbops.univ_mix_op.params.OUTPUT_RATE_FIELD = Output sampling rate $cbops.univ_mix_op.params.INTERP_PHASE_STEP_FIELD = Phase step = ((Interp input rate / Interp output rate) - 1) &gt;&gt; 3</p>
<p>$cbops.univ_mix_op.params.RESAMPLE_COEFS_ADDR_FIELD = FIR coefficient table pointer $cbops.univ_mix_op.params.RESAMPLE_COEFS_SIZE_FIELD = Number of coefficients </p><h2>$cbops.univ_mix_op.params.RESAMPLE_BUFFER_SIZE_FIELD = Number of data buffer elements </h2>
<hr/>
 <h2>Upsampler data structure fields (left &amp; right channels always unique) </h2>
<p>$cbops.univ_mix_op.data.PARAMETER_ADDR_FIELD = Pointer to the upsampler parameter structure (shown above)</p>
<p>$cbops.univ_mix_op.data.INPUT_BUFFER_ADDR_FIELD = Input buffer pointer $cbops.univ_mix_op.data.INPUT_BUFFER_LENGTH_FIELD = Length of input buffer $cbops.univ_mix_op.data.OUTPUT_BUFFER_ADDR_FIELD = Output buffer pointer $cbops.univ_mix_op.data.OUTPUT_BUFFER_LENGTH_FIELD = Length of output buffer</p>
<p>$cbops.univ_mix_op.data.INPUT_SAMPLES_REQUESTED_FIELD = Requested (available) samples to process $cbops.univ_mix_op.data.OUTPUT_SAMPLES_REQUESTED_FIELD = Requested number of output samples to generate</p>
<p>$cbops.univ_mix_op.data.INPUT_SAMPLES_READ_FIELD = Number of input samples read $cbops.univ_mix_op.data.OUTPUT_SAMPLES_WRITTEN_FIELD = Number of output samples written</p>
<p>$cbops.univ_mix_op.data.CURRENT_RAMP_GAIN_ADJUST_FIELD = Current gain (fractional) for the mixing volume adjustment $cbops.univ_mix_op.data.CURRENT_RAMP_SAMPLE_COUNT_FIELD = Input sample count between volume steps in the volume ramp $cbops.univ_mix_op.data.RAMP_CALLBACK_FIELD = Callback function pointer - if not NULL this is called on ramp completion</p>
<p>$cbops.univ_mix_op.data.RESAMPLE_BUFFER_ADDR_FIELD = FIR data buffer pointer</p>
<p>$cbops.univ_mix_op.data.INTERP_CURRENT_PHASE_FIELD = Internally calculated current phase value $cbops.univ_mix_op.data.INTERP_LAST_VAL_FIELD = Store for last FIR output value $cbops.univ_mix_op.data.LOCATION_IN_LOOP_FIELD = Internally calculated loop position state </p><hr/>
<p>RESTRICTIONS: The operator must NOT be used to output to a port (this is because the mixing function mixes in the output buffer using a read/mix/write operation).</p>
<p>Stereo or mono data inputs must be used (not a mixture).</p>
<p>The operator should NOT be chained with other operators using the same copy struct. This is because the number of input samples to be consumed is not actually calculated until the operator main is executed. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a9a2023eb29d1cd5a001b32d7c389763b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$cbops univ_mix_op calc_output_samples_helper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function for amount_to_use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r1 = pointer to the upsampler structure to use</li>
<li>r5 = the minimum of the number of input samples available and the amount of output space available</li>
<li>r6 = the number of input samples available</li>
<li>r7 = the amount of output space available</li>
<li>r8 = pointer to the parameter area of the operator structure</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>r1 = number of output samples</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0, r1</dd>
</dl>

</div>
</div>
<a class="anchor" id="a5840928c275231ad40006c7c60614ff8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$cbops univ_mix_op init_upsampler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize routine for the upsampler. Set up defaults which give unity gain and no upsampling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r5 = pointer to the FIR buffer</li>
<li>r6 = number of elements in the buffer</li>
<li>r7 = pointer to the upsampler data structure</li>
<li>r9 = pointer to the upsampler params structure</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>- r1, r2, r9</dd>
</dl>

</div>
</div>
<a class="anchor" id="a264cb63c1aea5d49eddd402bce854f63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$cbops univ_mix_op main_helper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main function helper to setup and call the upsampler function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r4 = flag to determine if output mixing is requested</li>
<li>r6 = pointer to the list of input and output buffer pointers</li>
<li>r7 = pointer to the list of buffer lengths</li>
<li>r8 = pointer to operator parameter structure</li>
<li>r9 = pointer to the upsampler structure to use</li>
<li>r10 = the number of samples to process</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>Assume all except r8, r9</dd>
</dl>

</div>
</div>
<a class="anchor" id="a52b4e02f7923ea7d36eedb6a1dbd0f3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$cbops univ_mix_op ramp_volume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Volume is ramped to desired value from current value. If the callback function pointer is not NULL, the address is called on completion of the volume ramp. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r1 = pointer to the current ramp gain</li>
<li>r8 = pointer to an instance of the upsampler data structure</li>
<li>r9 = pointer to an instance of the upsampler params structure</li>
<li>M1 = 1 </li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>r1 = gain (volume) value - fractional value 0.0-1.0</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>- r0, r2, rMAC</dd>
</dl>

</div>
</div>
<a class="anchor" id="af21a466f45cad96449c705e449457974"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$cbops univ_mix_op secondary_cbuffer_pointer_update </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to update the secondary cbuffer input pointers after buffer writing. This only needs to be called if both the primary and secondary channels are active. If the secondary channel ONLY is active then it is handled in the conventional way by cbops.copy. Also note that the output cbuffers will be updated by the primary channel (cbops.copy) so these do not need updating. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r6 = pointer to the list of input and output buffer pointers</li>
<li>r7 = pointer to the list of buffer lengths</li>
<li>r8 = pointer to operator parameter structure</li>
<li>r9 = pointer to the upsampler structure to use</li>
<li>r10 = the number of samples to process</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0-2, r10, I0, I1, I2, I3, L0, M1, M2</dd>
</dl>

</div>
</div>
<a class="anchor" id="aa82fa039ee3ce54d6f0c437f2dfed4aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$cbops univ_mix_op secondary_setup_helper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function for amount_to_use to set up the secondary channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>M1 = 1 </li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>r6 - minimum number of input samples available (in all input buffers)</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0, r1, r2, r3, r6, r10, I0, I1, I4</dd>
</dl>

</div>
</div>
<a class="anchor" id="ae24a6b1be9d15a8e829c0279d578e9e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$cbops univ_mix_op upsampler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Upsample data - input data is upsampled and filtered to produce output data at an integer multiple of the input rate. The ratios supported are dependent on the defined filter sets (currently these support ratios of 2, 4 and 6). Ratios which are not an integer multiple are also supported using linear interpolation between samples delivered by the upsampling process (e.g. can produce samples at a 44.1kHz sampling rate from samples at a 48kHz sampling rate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r4 = flag to determine if output mixing is requested</li>
<li>r5 = number of input samples available</li>
<li>r8 = pointer to an instance of the upsampler data structure</li>
<li>r10 = the number of output samples to deliver</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>Assume everything</dd>
</dl>
<dl>
<dt><b>Notes:</b></dt>
<dd><p class="startdd">Some resample filter coefficients are defined as part of the library. Six sets are defined: </p><pre class="fragment">   Name                                                                    Length
   $cbops.univ_mix_op.upsampler.resample_filter_coefs_x6_high_quality      60
   $cbops.univ_mix_op.upsampler.resample_filter_coefs_x4_high_quality      52
   $cbops.univ_mix_op.upsampler.resample_filter_coefs_x2_high_quality      40
   $cbops.univ_mix_op.upsampler.resample_filter_coefs_x6_low_quality       48
   $cbops.univ_mix_op.upsampler.resample_filter_coefs_x4_low_quality       40
   $cbops.univ_mix_op.upsampler.resample_filter_coefs_x2_low_quality       20
</pre><p> Each set of filters will only be included if they are referenced in your application code.</p>
<p>As well as the filter coefficients a circular resample buffer is required. This buffer needs to be declared in the application. The size of this buffer is dependent on the quality of filters used, higher quality requires longer filters, lower quality requires shorter filters.</p>
<p class="enddd"></p>
</dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 3 2018 03:05:06 for Kalimba DSP Reference Guide by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
