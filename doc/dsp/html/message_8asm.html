<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Kalimba DSP Reference Guide: core/message.asm File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Kalimba DSP Reference Guide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_4270bfced15e0e73154b13468c7c9ad9.html">core</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">message.asm File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This library contains functions to send and receive messages from the MCU or VM application.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aeb6ae3b3aae34199b2db22421890aebd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb6ae3b3aae34199b2db22421890aebd"></a>
Module: $message.&#160;</td><td class="memItemRight" valign="bottom"><b>initialise</b> </td></tr>
<tr class="separator:aeb6ae3b3aae34199b2db22421890aebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7065145c5b6f882f6c958249cd0a0e"><td class="memItemLeft" align="right" valign="top">Module: $message.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="message_8asm.html#afe7065145c5b6f882f6c958249cd0a0e">register_handler</a> </td></tr>
<tr class="memdesc:afe7065145c5b6f882f6c958249cd0a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a message handler function.  <a href="#afe7065145c5b6f882f6c958249cd0a0e">More...</a><br /></td></tr>
<tr class="separator:afe7065145c5b6f882f6c958249cd0a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628ee1e3166c9b8f0c0bd1c19332ea64"><td class="memItemLeft" align="right" valign="top">Module: $message.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="message_8asm.html#a628ee1e3166c9b8f0c0bd1c19332ea64">register_handler_with_mask</a> </td></tr>
<tr class="memdesc:a628ee1e3166c9b8f0c0bd1c19332ea64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a message handler function with a mask.  <a href="#a628ee1e3166c9b8f0c0bd1c19332ea64">More...</a><br /></td></tr>
<tr class="separator:a628ee1e3166c9b8f0c0bd1c19332ea64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa69714aeeba2819c8180e9f582eaa69a"><td class="memItemLeft" align="right" valign="top">Module: $message.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="message_8asm.html#aa69714aeeba2819c8180e9f582eaa69a">register_default_handler</a> </td></tr>
<tr class="memdesc:aa69714aeeba2819c8180e9f582eaa69a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a message handler function.  <a href="#aa69714aeeba2819c8180e9f582eaa69a">More...</a><br /></td></tr>
<tr class="separator:aa69714aeeba2819c8180e9f582eaa69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1749c4019ea8853289681189d4cfa405"><td class="memItemLeft" align="right" valign="top">Module: $message.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="message_8asm.html#a1749c4019ea8853289681189d4cfa405">unregister_handler</a> </td></tr>
<tr class="memdesc:a1749c4019ea8853289681189d4cfa405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister a message handler function.  <a href="#a1749c4019ea8853289681189d4cfa405">More...</a><br /></td></tr>
<tr class="separator:a1749c4019ea8853289681189d4cfa405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa663552349c80c8a2cc288f2d267e053"><td class="memItemLeft" align="right" valign="top">Module: $message.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="message_8asm.html#aa663552349c80c8a2cc288f2d267e053">send</a> </td></tr>
<tr class="memdesc:aa663552349c80c8a2cc288f2d267e053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a short or long message to the mcu/vm. If a previous message is waiting to be acknowledged then the new message is placed in the queue and a timer is set to attempt to resend it after a small period of time.  <a href="#aa663552349c80c8a2cc288f2d267e053">More...</a><br /></td></tr>
<tr class="separator:aa663552349c80c8a2cc288f2d267e053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdb93a5a4ef6d8259f5132eb3ac9b1da"><td class="memItemLeft" align="right" valign="top">Module: $message.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="message_8asm.html#abdb93a5a4ef6d8259f5132eb3ac9b1da">send_long</a> </td></tr>
<tr class="memdesc:abdb93a5a4ef6d8259f5132eb3ac9b1da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a long message to the mcu/vm. If a previous message is waiting to be acknowledged then the new message is placed in the queue and a timer is set to attempt to resend it after a small period of time.  <a href="#abdb93a5a4ef6d8259f5132eb3ac9b1da">More...</a><br /></td></tr>
<tr class="separator:abdb93a5a4ef6d8259f5132eb3ac9b1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8c62dfeebb07350c5009f8327b5500"><td class="memItemLeft" align="right" valign="top">Module: $message.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="message_8asm.html#ada8c62dfeebb07350c5009f8327b5500">send_short</a> </td></tr>
<tr class="memdesc:ada8c62dfeebb07350c5009f8327b5500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a short message to the mcu/vm. If a previous message is waiting to be acknowledged then the new message is placed in the queue and a timer is set to attempt to resend it after a small period of time.  <a href="#ada8c62dfeebb07350c5009f8327b5500">More...</a><br /></td></tr>
<tr class="separator:ada8c62dfeebb07350c5009f8327b5500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe097bee0fcbca3a5884d7088840673"><td class="memItemLeft" align="right" valign="top">Module: $message.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="message_8asm.html#abfe097bee0fcbca3a5884d7088840673">send_queue_fullness</a> </td></tr>
<tr class="memdesc:abfe097bee0fcbca3a5884d7088840673"><td class="mdescLeft">&#160;</td><td class="mdescRight">See how full the Kalimba side send message queue is.  <a href="#abfe097bee0fcbca3a5884d7088840673">More...</a><br /></td></tr>
<tr class="separator:abfe097bee0fcbca3a5884d7088840673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c896a068fcc6eec79a930c02e62d0b2"><td class="memItemLeft" align="right" valign="top">Module: $message.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="message_8asm.html#a1c896a068fcc6eec79a930c02e62d0b2">send_queue_space</a> </td></tr>
<tr class="memdesc:a1c896a068fcc6eec79a930c02e62d0b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">See how much space there is in the Kalimba side send message queue.  <a href="#a1c896a068fcc6eec79a930c02e62d0b2">More...</a><br /></td></tr>
<tr class="separator:a1c896a068fcc6eec79a930c02e62d0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07587b67fc3112a3f2045169a4afa159"><td class="memItemLeft" align="right" valign="top">Module: $message.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="message_8asm.html#a07587b67fc3112a3f2045169a4afa159">received_service_routine</a> </td></tr>
<tr class="memdesc:a07587b67fc3112a3f2045169a4afa159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a message from the MCU/VM once an interrupt has occured and call the appropriate message handler function.  <a href="#a07587b67fc3112a3f2045169a4afa159">More...</a><br /></td></tr>
<tr class="separator:a07587b67fc3112a3f2045169a4afa159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8fc98ed2735c8635906a73643cd155d"><td class="memItemLeft" align="right" valign="top">Module: $M.message&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="message_8asm.html#aa8fc98ed2735c8635906a73643cd155d">log</a> </td></tr>
<tr class="memdesc:aa8fc98ed2735c8635906a73643cd155d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug code to log messages sent and received by the Kalimba DSP.  <a href="#aa8fc98ed2735c8635906a73643cd155d">More...</a><br /></td></tr>
<tr class="separator:aa8fc98ed2735c8635906a73643cd155d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676232abf5d8eb6aaf71f2f3d747492e"><td class="memItemLeft" align="right" valign="top">Module: $message.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="message_8asm.html#a676232abf5d8eb6aaf71f2f3d747492e">send_ready_wait_for_go</a> </td></tr>
<tr class="memdesc:a676232abf5d8eb6aaf71f2f3d747492e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send the $MESSAGE_KALIMBA_READY message and wait for the $MESSAGE_GO message.  <a href="#a676232abf5d8eb6aaf71f2f3d747492e">More...</a><br /></td></tr>
<tr class="separator:a676232abf5d8eb6aaf71f2f3d747492e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6adb2060a7b0eb90c828c668db348cbf"><td class="memItemLeft" align="right" valign="top">Module: $message.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="message_8asm.html#a6adb2060a7b0eb90c828c668db348cbf">send_ready_with_meta_wait_for_go</a> </td></tr>
<tr class="memdesc:a6adb2060a7b0eb90c828c668db348cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send the $MESSAGE_KALIMBA_READY_WITH_META message and wait for the $MESSAGE_GO message.  <a href="#a6adb2060a7b0eb90c828c668db348cbf">More...</a><br /></td></tr>
<tr class="separator:a6adb2060a7b0eb90c828c668db348cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This library contains functions to send and receive messages from the MCU or VM application. </p>
<p><em>[SDK Folder]</em>/src/kalimba/core/message.asm</p>
<p>Part of ADK_CSR867x.WIN. 4.4</p>
<h1>Messaging Library</h1>
<p>Messages are sent using interrupts and a shared memory window to carry the message payload. Messages have a 16-bit ID, with up to four 16-bit words of data.</p>
<h3>Reserved message IDs</h3>
<p>Messages with an ID greater than 0x8000 are reserved for use by the firmware and VM for background maintenance. When a message is received by the Kalimba, a subroutine is called to process the message. Up to 50 such message types may be 'registered' in this way. This may be changed by editing the definition of $message.MAX_MESSAGE_HANDLERS in message.h.</p>
<p>On the Kalimba side, up to 20 'short' messages may be queued for processing by the MCU defined by $message.QUEUE_SIZE_IN_MSGS in message.h. The queue fullness and space can be determined by calling $message.send_queue_fullness and $message.send_queue_space respectively. If the queue is full and a further message send is attempted the error routine will be called if MESSAGE_ERROR_IF_QUEUE_FULL is defined (debug mode). Otherwise the further message is silently discarded. Messages from the VM are not queued, however calls to KalimbaSendMessage will fail until the previous message has been processed by the Kalimba.</p>
<h3>Long messages</h3>
<p>The message library has been extended to support sending and receiving of 'long messages', these are transported using the underlying 'short' message system. Long messages can be of variable length. For details of sending and receiving long messages look at $message.send_long and $message.received_service_routine respectively. There is an example app to demonstrate long message support, as well as reading PS keys, in [BlueLab]/apps/examples/kalimba_long_message_example/</p>
<p>When sending a long message the data is buffered through the system as it is broken up into and then reconstructed from short messages. Typically the message is buffered as {ID, length, payload}. Consequently the size of a message is really (payload + 2).</p>
<h3>Sending messages</h3>
<p>When sending a long message from the DSP to the VM, it is buffered in two places before delivery to the VM application. Firstly within the DSP in $message.queue where it is stored as a series of 4-word short messages for sending, secondly it is buffered in the Firmware as it is reconstructed from these short messages. The Firmware buffer is dynamically allocated and so is limited by the available resources when you send your message.</p>
<p>The size of the message queue ($message.queue) is defined interms of the largest long message payload that can be sent - $message.MAX_LONG_MESSAGE_TX_PAYLOAD_SIZE, defined in message.h, currently set to 80. Note, this figure does not include the ID and length, so the XAP needs to allocate a buffer of size 82 to receive such a message.</p>
<p>Changing this value will allow the DSP to send larger or smaller messages however it does not guarantee resources in the XAP to receive the message. If you wish to send larger messages, change the value and rebuild your DSP libraries. Then you will have to test your applicattion has suitable resources available at run time.</p>
<h3>Receiving messages</h3>
<p>When receiving a long message from the VM, the message is buffered in the firmware buffer and then in the DSP in $message.long_message_data, which is of size $message.LONG_MESSAGE_BUFFER_SIZE. This figure is calculated so it is large enough to receive a message with a payload size of $message.MAX_LONG_MESSAGE_RX_PAYLOAD_SIZE - currently set to 80 in message.h. Again this figure does not include the ID and length so the XAP needs to be able to allocate an 82 word bufffer to send the message.</p>
<h3>PS key requests</h3>
<p>When the DSP requests a PS key, the firmware uses a special buffer of size</p><ol type="1">
<li>This contains the PS key ID as the first word and the PS key body as the payload meaning the largest key that can be retrieved is of size 63. This is then sent directly to the DSP which receives the message in $message.long_message_data, consequently the Firmware buffer is the limiting buffer and so the largest PS key that the DSP can request the Firmware to retrieve is of size 63.</li>
</ol>
<p>Typically, latencies of less than 1ms are encountered by messages passed from the MCU to the Kalimba. In the other direction, the MCU may take upto 20ms to process a message. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aa8fc98ed2735c8635906a73643cd155d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$M message log </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Debug code to log messages sent and received by the Kalimba DSP. </p>
<p>The routine stores the message timing, IDs and parameters in a message table (data array). Short messages are stored with all parameters but long messages are truncated. The direction (tx/rx) of the message is also stored as a flag in the msb of the message ID data word.</p>
<p>Only the first $MAX_NUM_LOG_MESSAGES will be stored. These can be retrieved from memory using a debugger of choice or the custom python script msgdec.py.</p>
<p>Note: some messages are not logged by default since these rapidly fill the log array and prevent the capture of other possibly more meaningful data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>Standard (short) message mode:<ul>
<li>r0 = message ID | &lt;rx:0|tx:0x800000&gt;</li>
<li>r1 = message Data 0</li>
<li>r2 = message Data 1</li>
<li>r3 = message Data 2</li>
<li>r4 = message Data 3</li>
</ul>
</li>
<li>Long message mode:<ul>
<li>r0 = $message.LONG_MESSAGE_MODE_ID</li>
<li>r1 = long message ID | &lt;rx:0|tx:0x800000&gt; (the actual ID of the message to send)</li>
<li>r2 = long message size (in words)</li>
<li>r3 = long message address of payload</li>
</ul>
</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>DoLoop</dd>
</dl>

</div>
</div>
<a class="anchor" id="a07587b67fc3112a3f2045169a4afa159"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$message received_service_routine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive a message from the MCU/VM once an interrupt has occured and call the appropriate message handler function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>assume everything</dd>
</dl>
<dl>
<dt><b>Notes:</b></dt>
<dd><p class="startdd">The handler function is passed:</p><ul>
<li>Standard (short) message mode:<ul>
<li>r0 = message ID</li>
<li>r1 = message Data 0</li>
<li>r2 = message Data 1</li>
<li>r3 = message Data 2</li>
<li>r4 = message Data 3</li>
</ul>
</li>
<li>Long message mode:<ul>
<li>r0 = $message.LONG_MESSAGE_MODE_ID (a special flag to imply long message mode)</li>
<li>r1 = long message ID (the actual ID of the message to send)</li>
<li>r2 = long message size (in words)</li>
<li>r3 = long message address of payload</li>
</ul>
</li>
</ul>
<p>The handler function can trash any register (the ISR will restore everything)</p>
<p class="enddd"></p>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="aa69714aeeba2819c8180e9f582eaa69a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$message register_default_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a message handler function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r1 = pointer to a variable that stores the message handler structure, should be of length $message.STRUC_SIZE</li>
<li>r3 = message handler address for this message ID</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0, r3</dd>
</dl>

</div>
</div>
<a class="anchor" id="afe7065145c5b6f882f6c958249cd0a0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$spi_comm register_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a message handler function. </p>
<p>Registers a PIO event handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r1 = pointer to a variable that stores the message handler structure, should be of length $message.STRUC_SIZE</li>
<li>r2 = message ID</li>
<li>r3 = message handler address for this message ID</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0, r1</dd>
</dl>
<p>INPUTS</p><ul>
<li>r0 = pointer to a structure that stores the pio handler structure, should be of length $pio.STRUC_SIZE</li>
<li>r1 = bitmask of PIOs to monitor (PIO_IN register: PIO[23:0])</li>
<li>r2 = bitmask of PIOs to monitor (PIO2_IN register: AIO[15:0] PIO[31:24])</li>
<li>r3 = bitmask of PIOs to monitor (PIO3_IN register: AIO[31:16])</li>
<li>r4 = address of PIO event handler for this PIO</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0-4</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r1 = pointer to a variable that stores the message handler structure, should be of length $spi_comm.STRUC_SIZE</li>
<li>r2 = message ID</li>
<li>r3 = message handler address for this message ID</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0, r1, r2 , r3</dd>
</dl>
<dl>
<dt><b>Notes:</b></dt>
<dd>It updates the message handler linked list by updating the last_addr and next_addr fields in the spi_comm data structure to point to appropriate message handlers. </dd>
</dl>

</div>
</div>
<a class="anchor" id="a628ee1e3166c9b8f0c0bd1c19332ea64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$message register_handler_with_mask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a message handler function with a mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r1 = pointer to a variable that stores the message handler structure, should be of length $message.STRUC_SIZE</li>
<li>r2 = message ID</li>
<li>r3 = message handler address for this message ID</li>
<li>r4 = mask to apply to received ID before comparing</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0, r1, r4</dd>
</dl>
<dl>
<dt><b>Notes:</b></dt>
<dd><p class="startdd">This function allows you to specify a mask to apply to the received message ID before comparing it. This allows a single handler to be registered to receive a range of IDs: </p><pre class="fragment">   IDs:            0x2000 - 0x20FF          0x0000-0x0003

   Registered ID:  0x2000                   0x0000
   Mask:           0x00FF                   0x0003
</pre><p>As with $message.register_handler, the handler is passed the ACTUAL ID received by the service routine NOT the masked version.</p>
<p class="enddd"></p>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="aa663552349c80c8a2cc288f2d267e053"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$message send </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a short or long message to the mcu/vm. If a previous message is waiting to be acknowledged then the new message is placed in the queue and a timer is set to attempt to resend it after a small period of time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>Standard (short) message mode:<ul>
<li>r2 = message ID</li>
<li>r3 = message Data 0</li>
<li>r4 = message Data 1</li>
<li>r5 = message Data 2</li>
<li>r6 = message Data 3</li>
</ul>
</li>
<li>Long message mode:<ul>
<li>r2 = $message.LONG_MESSAGE_MODE_ID (a special flag to imply long message mode)</li>
<li>r3 = long message ID (the actual ID of the message to send)</li>
<li>r4 = long message size (in words)</li>
<li>r5 = long message address of payload</li>
</ul>
</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0, r1, r2, r3, r4, r5, r6, r10, DoLoop</dd>
</dl>

</div>
</div>
<a class="anchor" id="abdb93a5a4ef6d8259f5132eb3ac9b1da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$message send_long </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a long message to the mcu/vm. If a previous message is waiting to be acknowledged then the new message is placed in the queue and a timer is set to attempt to resend it after a small period of time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r3 = long message ID (the actual ID of the message to send)</li>
<li>r4 = long message size (in words)</li>
<li>r5 = long message address of payload</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0, r1, r2, r3, r4, r5, r6, r10, DoLoop</dd>
</dl>

</div>
</div>
<a class="anchor" id="abfe097bee0fcbca3a5884d7088840673"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$message send_queue_fullness </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See how full the Kalimba side send message queue is. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>r0 = Queue fullness (number of words still to be sent)</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>none</dd>
</dl>

</div>
</div>
<a class="anchor" id="a1c896a068fcc6eec79a930c02e62d0b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$message send_queue_space </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See how much space there is in the Kalimba side send message queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>r0 = Queue space (number of words available)</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>none</dd>
</dl>

</div>
</div>
<a class="anchor" id="a676232abf5d8eb6aaf71f2f3d747492e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$message send_ready_wait_for_go </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send the $MESSAGE_KALIMBA_READY message and wait for the $MESSAGE_GO message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0, r1, r2, r3, r4, r5, r6, r10, DoLoop</dd>
</dl>

</div>
</div>
<a class="anchor" id="a6adb2060a7b0eb90c828c668db348cbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$message send_ready_with_meta_wait_for_go </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send the $MESSAGE_KALIMBA_READY_WITH_META message and wait for the $MESSAGE_GO message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 - metadata enable flags</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0, r1, r2, r3, r4, r5, r6, r10, DoLoop</dd>
</dl>

</div>
</div>
<a class="anchor" id="ada8c62dfeebb07350c5009f8327b5500"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$message send_short </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a short message to the mcu/vm. If a previous message is waiting to be acknowledged then the new message is placed in the queue and a timer is set to attempt to resend it after a small period of time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r2 = message ID</li>
<li>r3 = message Data 0</li>
<li>r4 = message Data 1</li>
<li>r5 = message Data 2</li>
<li>r6 = message Data 3</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0, r1, r2, r3, r4, r5, r6, r10, DoLoop</dd>
</dl>

</div>
</div>
<a class="anchor" id="a1749c4019ea8853289681189d4cfa405"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$message unregister_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister a message handler function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r3 = message ID</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0, r1, r2</dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 3 2018 03:05:07 for Kalimba DSP Reference Guide by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
