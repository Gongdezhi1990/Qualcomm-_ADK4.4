<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Kalimba DSP Reference Guide: core/interrupt.asm File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Kalimba DSP Reference Guide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_4270bfced15e0e73154b13468c7c9ad9.html">core</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">interrupt.asm File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This library has functions to setup the interrupt controller, block and unblock interrupts, and also a standard interrupt service routine (ISR). The ISR currently handles just MCU and timer1 interrupt sources, but may be extended if required.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6d8bc7f0197f397df8af700518fc7d82"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d8bc7f0197f397df8af700518fc7d82"></a>
Module: $interrupt.&#160;</td><td class="memItemRight" valign="bottom"><b>initialise</b> </td></tr>
<tr class="separator:a6d8bc7f0197f397df8af700518fc7d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632280aebe871f363ed39a653c153ae2"><td class="memItemLeft" align="right" valign="top">Module&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interrupt_8asm.html#a632280aebe871f363ed39a653c153ae2">$block_interrupts</a> </td></tr>
<tr class="memdesc:a632280aebe871f363ed39a653c153ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block interrupts subroutine, NOTE this may also be called using $interrupt.block.  <a href="#a632280aebe871f363ed39a653c153ae2">More...</a><br /></td></tr>
<tr class="separator:a632280aebe871f363ed39a653c153ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afafaaffeb8bcdbea197a608520844164"><td class="memItemLeft" align="right" valign="top">Module&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interrupt_8asm.html#afafaaffeb8bcdbea197a608520844164">$unblock_interrupts</a> </td></tr>
<tr class="memdesc:afafaaffeb8bcdbea197a608520844164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unblock interrupts subroutine, NOTE this may also be called using $interrupt.unblock.  <a href="#afafaaffeb8bcdbea197a608520844164">More...</a><br /></td></tr>
<tr class="separator:afafaaffeb8bcdbea197a608520844164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeed51117f92c3bdf20c2c564fce9c87"><td class="memItemLeft" align="right" valign="top">Module: $interrupt.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interrupt_8asm.html#abeed51117f92c3bdf20c2c564fce9c87">register</a> </td></tr>
<tr class="memdesc:abeed51117f92c3bdf20c2c564fce9c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers an interrupt handler for a particular interrupt source, and sets the priority as required.  <a href="#abeed51117f92c3bdf20c2c564fce9c87">More...</a><br /></td></tr>
<tr class="separator:abeed51117f92c3bdf20c2c564fce9c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba127aa7941a2ba00904a9e60b75b688"><td class="memItemLeft" align="right" valign="top">Module: $interrupt.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interrupt_8asm.html#aba127aa7941a2ba00904a9e60b75b688">register_fast</a> </td></tr>
<tr class="memdesc:aba127aa7941a2ba00904a9e60b75b688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a fast interrupt handler for a particular interrupt source, and sets the priority as required.  <a href="#aba127aa7941a2ba00904a9e60b75b688">More...</a><br /></td></tr>
<tr class="separator:aba127aa7941a2ba00904a9e60b75b688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e802402f573be8c529a12cfaf6b489"><td class="memItemLeft" align="right" valign="top">Module: $interrupt.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interrupt_8asm.html#a39e802402f573be8c529a12cfaf6b489">handler</a> </td></tr>
<tr class="memdesc:a39e802402f573be8c529a12cfaf6b489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt handler that's compatible with the various library functions CSR supply.  <a href="#a39e802402f573be8c529a12cfaf6b489">More...</a><br /></td></tr>
<tr class="separator:a39e802402f573be8c529a12cfaf6b489"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This library has functions to setup the interrupt controller, block and unblock interrupts, and also a standard interrupt service routine (ISR). The ISR currently handles just MCU and timer1 interrupt sources, but may be extended if required. </p>
<p><em>[SDK Folder]</em>/src/kalimba/core/interrupt.asm</p>
<p>Part of ADK_CSR867x.WIN. 4.4</p>
<h1>Interrupt Library</h1>
<p>Upon an interrupt, the Kalimba DSP jumps to location 0x0002, copies the user mode flags values to the interrupt mode bits (MSbyte).</p>
<p>The Kalimba supports four interrupt priority levels. Level zero does not interrupt the Kalimba but will wake it up from a sleep instruction. An interrupt source with a higher interrupt priority may interrupt the ISR if the UM flag is set.</p>
<p>The Kalimba DSP has eight interrupt sources: four software based events; two timer events; a PIO event and an MCU event. To enable an interrupt source, enable its bitfield in $INT_SOURCES_EN, set its priority to greater than 0 in $INT_PRIORITIES and write 1 to $INT_GBL_ENABLE and $INT_ENABLE to enable Kalimba DSP interrupts. $INT_GBL_ENABLE is used to reset the interrupt handler; no interrupts are recorded or allowed when this is zero. $INT_ENABLE is used to prevent interrupts firing, when $INT_ENABLE is high, any interrupts will then trigger.</p>
<p>To block and unblock interrupts, call the $block_interrupts and $unblock_interrupts subroutines; for interrupts to be enabled, the $unblock_interrupts must be called as many times as $block_interrupts has been called. This allows for nested subroutines to block and unblock interrupts in a consistent manner. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a632280aebe871f363ed39a653c153ae2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$block_interrupts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block interrupts subroutine, NOTE this may also be called using $interrupt.block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0</dd>
</dl>

</div>
</div>
<a class="anchor" id="afafaaffeb8bcdbea197a608520844164"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$unblock_interrupts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unblock interrupts subroutine, NOTE this may also be called using $interrupt.unblock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0</dd>
</dl>

</div>
</div>
<a class="anchor" id="a39e802402f573be8c529a12cfaf6b489"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$interrupt handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt handler that's compatible with the various library functions CSR supply. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>none (all are saved and restored)</dd>
</dl>
<dl>
<dt><b>Notes:</b></dt>
<dd><p class="startdd">The ISR code now supports both single interrupt priority mode (no nested interrupts) and also multiple priority (nested interrupts). By default the non nested interrupt mode is selected. To use the nested interrupt version you need to enable the define of NESTED_INTERRUPT_SUPPORT in interrupt.h</p>
<p class="enddd"></p>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="abeed51117f92c3bdf20c2c564fce9c87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$rotary_enc register </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers an interrupt handler for a particular interrupt source, and sets the priority as required. </p>
<p>Register the memory structure of a rotary encoder and initialise it.</p>
<p>Register a routine to be profiled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 - Interrupt Source (eg. $INT_SOURCE_PIO_EVENT)</li>
<li>r1 - Interrupt Priority (1 lowest -&gt; 3 highest, 0 wakeup)</li>
<li>r2 - Function address to call upon interrupt</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0, r3, r5</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = pointer to a variable that stores the profiling structure, should be of length $profiler.STRUC_SIZE</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r1</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = pointer to a rotary_enc structure</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0, r1, r2</dd>
</dl>
<dl>
<dt><b>Notes:</b></dt>
<dd><p class="startdd">All memory structures should be registered before the $message.send_ready_wait_for_go routine is called.</p>
<p class="enddd"></p>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="aba127aa7941a2ba00904a9e60b75b688"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$interrupt register_fast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a fast interrupt handler for a particular interrupt source, and sets the priority as required. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 - Interrupt Source (eg. $INT_SOURCE_PIO_EVENT)</li>
<li>r1 - Interrupt Priority (1 lowest -&gt; 3 highest, 0 wakeup)</li>
<li>r2 - Function address to call upon interrupt</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>none</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0, r3, r5</dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 3 2018 03:05:07 for Kalimba DSP Reference Guide by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
