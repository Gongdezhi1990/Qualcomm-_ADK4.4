<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Kalimba DSP Reference Guide: codec/stream_decode.asm File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Kalimba DSP Reference Guide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_aa853d00c7731606ea7501eb695351f4.html">codec</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">stream_decode.asm File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3cdec19280f60adfebc5390091e7689f"><td class="memItemLeft" align="right" valign="top">Module: $codec.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream__decode_8asm.html#a3cdec19280f60adfebc5390091e7689f">stream_decode</a> </td></tr>
<tr class="memdesc:a3cdec19280f60adfebc5390091e7689f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes a codec stream (deals with overflow/underflow and attempts to handle the 'real' BT issues such as: packet jitter, non-perfect sample rates, going out of range, etc)  <a href="#a3cdec19280f60adfebc5390091e7689f">More...</a><br /></td></tr>
<tr class="separator:a3cdec19280f60adfebc5390091e7689f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><em>[SDK Folder]</em>/src/kalimba/codec/stream_decode.asm</p>
<p>Part of ADK_CSR867x.WIN. 4.4</p>
<p>/*! </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a3cdec19280f60adfebc5390091e7689f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Module: $spdif.stream_decode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decodes a codec stream (deals with overflow/underflow and attempts to handle the 'real' BT issues such as: packet jitter, non-perfect sample rates, going out of range, etc) </p>
<p>decoding audio data received from S/PDIF input interface.</p>
<p>S/PDIF stream decode module is responsible for decoding audio data received from S/PDIF input interface. The input stream is in IEC-61937 standard format, S/PDIF stream decode module extract audio data from the input stream by calling S/PDIF frame copy module. The input data can be either in PCM or CODED format, PCM data are always extracted and routed to output stereo LEFT and RIGHT buffers. For coded data, this library either invokes a proper decoder or simply mutes the output while receiving coded data. User can configure what data types shall be decoded and also shall provide proper decoder for the data types that wants to support. The library also handles smooth transition between PCM and CODED data or between two different CODED data types.</p>
<p>MODIFICATIONS: 3.3 04/10/05 DRH BlueLab 3.3 release</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r5 = pointer to a codec.stream_decode structure<ul>
<li>ADDR_FIELD<ul>
<li>frame_decode function - routine to call to decode a frame of codec data.</li>
</ul>
</li>
<li>RESET_ADDR_FIELD<ul>
<li>reset decoder function - routine to call to reset the decoder.</li>
</ul>
</li>
<li>SILENCE_ADDR_FIELD<ul>
<li>silence decoder function - routine to call to clear internal codec buffers, used to clear any audio remains from a previous decode.</li>
</ul>
</li>
<li>IN_BUFFER_FIELD<ul>
<li>input codec cbuffer structure - cbuffer from where the decoder should read the input compressed codec data.</li>
</ul>
</li>
<li>OUT_LEFT_BUFFER_FIELD<ul>
<li>left output cbuffer structure - cbuffer where the decoder should write the decoded left audio samples.</li>
</ul>
</li>
<li>OUT_RIGHT_BUFFER_FIELD<ul>
<li>right output cbuffer structure - cbuffer where the decoder should write the decoded right audio samples.</li>
</ul>
</li>
<li>MODE_FIELD<ul>
<li>internal mode data - initialise to 0.</li>
</ul>
</li>
<li>NUM_OUTPUT_SAMPLES_FIELD<ul>
<li>internal state data - initialise to 0.</li>
</ul>
</li>
<li>DECODER_DATA_OBJECT_FIELD<ul>
<li>decoder data object pointer</li>
</ul>
</li>
<li>COMFORT_NOISE_GAIN_FIELD<ul>
<li>comfort noise gain - when the data supplied to the decoder fails for some reason, eg out of Bluetooth range, the volume of comfort noise that should be played. Set to 0 to output silence in the abscence of data. Range (0 - 1.0).</li>
</ul>
</li>
<li>GOOD_WORKING_BUFLEVEL_FIELD<ul>
<li>good working buffer level - input codec buffer level (%) required before decoding starts. Decreasing this value will reduce the latency of the decoder but will also reduce the tolerance to jitter in the average data rate. This should be modified in parallel with considerations of the size of input codec cbuffer, see below.</li>
</ul>
</li>
<li>POORLINK_DETECT_BUFLEVEL_FIELD<ul>
<li>poorlink detect buffer level - if the codec buffer empties the decoder will examine the buffer level history and determine if the link is poor. The decoder may have simply reached the end of the current audio track. If historical level was below the value specified by this parameter the link is deemed to be poor and poorlink is flagged, see below. Note this value is a percentage of the good working buffer level, not the actual buffer size.</li>
</ul>
</li>
<li>POORLINK_PERIOD_FIELD<ul>
<li>poorlink period - when poorlink has been flagged the decoder will not release the flag until a good data rate has been continuously sustained for this duration, measured in micro-seconds.</li>
</ul>
</li>
<li>PLAYING_ZERO_DATARATE_PERIOD_FIELD<ul>
<li>zero data period - during the "playing" state if no data is received for this duration of time the decoder enters the "buffering" state. It assumes the source has "paused" and so should output silence until the good working buffer level is restored.</li>
</ul>
</li>
<li>BUFFERING_ZERO_DATARATE_PERIOD_FIELD<ul>
<li>zero datarate period - if the input buffer has some data in it, and the decoder is in the "buffering" state for this period of time without receiving any further data, then the decoder plays out the input buffer. This is mode of operation is required so that small audio clips which would otherwise not reach the good working buffer level are played out as they are received (i.e. not queued up until the good working level is reached).</li>
</ul>
</li>
<li>POORLINK_DETECT_TABLE_ADDR_FIELD<ul>
<li>address of the poorlink table - a table used to store the buffer level history, used to detect the poorlink condition.</li>
</ul>
</li>
<li>POORLINK_DETECT_TABLE_SIZE_FIELD<ul>
<li>size of the poorlink table</li>
</ul>
</li>
<li>WARP_RATE_HIGH_COEF_FIELD<ul>
<li>high warp rate coefficient - a measure of the amount of warp to apply, when the buffer level is quite far out from the good working buffer level, see below.</li>
</ul>
</li>
<li>WARP_RATE_LOW_COEF_FIELD<ul>
<li>low warp rate coefficient - a measure of the amount of warp to apply, when the buffer level is quite close to the good working buffer level, see below.</li>
</ul>
</li>
<li>WARP_RATE_TRANSITION_LEVEL_FIELD<ul>
<li>warp transition level (between high and low coefs being used) - sets the buffer difference in words at which point coef 'HIGH' starts to be used.</li>
</ul>
</li>
</ul>
</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>r0 = $codec.STREAM_CAN_IDLE / $codec.STREAM_DONT_IDLE (this can be used to decide whether to have an idle period to save power)</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>assume everything</dd>
</dl>
<dl>
<dt><b>Notes:</b></dt>
<dd><pre class="fragment">                               GOOD_WORKING_BUFLEVEL
                                            |
         ___________________________________V___________________
        |                 decoder input buffer                  |
        |_______________________________________________________|
       Empty                                                  Full
    (0 bytes)                                              (N bytes)</pre><p>GOOD_WORKING_BUFLEVEL - decoding starts when at least this amount of data is in the cbuffer. This is the main buffer in the system to accomodate jitter from packet retries etc.</p>
<p>POOR_LINK detection - If it appears that the BT link is not sustaining the required rate for realtime audio, then the POORLINK condition is flagged. This causes the output to be muted for a certain period. If during this period no further POORLINK conditions have been detected then the audio will start playing again, otherwise it will continue muting the audio.</p>
<p>WARP_RATE_HIGH/LOW_COEF - this follows the equation: </p><pre class="fragment"> RequestedWarpRate(%) = WarpRateCoef/167772 * (buffer level difference in bytes)

 Example: suppose 1% warping is required when the buffer level discrepency is
 500 bytes, applying the above equation gives a warp rate coefficient of 336.</pre><p class="enddd"></p>
</dd>
</dl>
<p>Some optional features that are or will be supported by this library:</p>
<p>Output Interface Control: S/PDIF library can control output consuming interface, This allows to activate and deactivate the output interface according to the state of S/PDIF input interface, it also allows to configure the output rate when the input rate changes. The library handles all low level communication to firmware so handling the output interface will be hidden from the application. The library only supports DAC, I2S and S/PDIF stereo output interfaces.</p>
<p>Latency Measurement: S/PDIF library can measure the latency that is presents due to S/PDIF related buffers, these are input raw data buffer, PCM output buffer and coded data buffer. The measured latency will be used by the application to control the latency of the system.</p>
<p>VM message communication: Various information might be needed by the vm about the S/PDIF input stream, this info are not available directly from vm because its DSP that communicate to firmware. S/PDIF stream decode can communicate to vm and let vm knows the state of S/PDIF input stream.</p>
<p>NOTE: This is only for decoding input spdif stream. There might be a S/PDIF stream encode sub library in future, that will enable apps to send coded data via S/PDIF output interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td>r8 = spdif stream decode structure, fields are described below: SPDIF_FRAME_COPY_STRUCT_FIELD (config) = pointer to spdif "frame copy" structure, frame copy module is invoked by this function to extract PCM and coded data from spdif raw input. Some of the user configuration will be via this structure.</td></tr>
  </table>
  </dd>
</dl>
<p>GET_DECODER_FUNCTION_PTR_FIELD (config) = call back function to get decoder info, this has to be configured by the application. This field can be null if user wants PCM audio only. The function is called whenever codec type changes, and the app is supposed to provide the following info for the codec type: 1- decoder structure 2- frame decode function 3- reset decoder function (can be null)</p>
<p>MASTER_RESET_FUNCTION_FIELD (config) = A master reset function that is supplied by the app, the function is called when data type changes.</p>
<p>MODE_FIELD (output): determines the output result, can be either $spdif.SUCCESS, $spdif.NOT_ENOUGH_INPUT_DATA, or $spdif.NOT_ENOUGH_OUTPUT_SPACE, depending on the frame copy output and also the decoder output when applicable</p>
<p>frame copy output decoder output output x NA = frame copy output Success X Success Not Success X decoder output</p>
<p>CURRENT_CODEC_TYPE_FIELD (internal state) current CODED data type that is processed by this module</p>
<p>DECODER_DECODE_STRUCT_FIELD (internal state) decoder input structure received from app via call back function</p>
<p>DECODER_FRAME_DECODE_FUNCTION_FIELD (internal state) decoder frame decode function received from app via call back function</p>
<p>DECODER_RESET_FUNCTION_FIELD (internal state) decoder reset function received from app via call back function</p>
<p>CODEC_IS_DECODING_FIELD = flag showing whether decoder is currently decoding or run out of data</p>
<p>STALL_COPYING_FIELD flag showing copying shall be stalled now, stall happens when codec type has to change and the decoder is still decoding old data type</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OUTPUTS</td><td>None</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>assume everything</dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 3 2018 03:05:07 for Kalimba DSP Reference Guide by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
