<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Kalimba DSP Reference Guide: math/fft.asm File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Kalimba DSP Reference Guide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_296d53ceaeaa7e099814a6def439fe8a.html">math</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">fft.asm File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a15696f881fa3811525c41fa0c7766539"><td class="memItemLeft" align="right" valign="top">Module: $math.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fft_8asm.html#a15696f881fa3811525c41fa0c7766539">fft</a> </td></tr>
<tr class="memdesc:a15696f881fa3811525c41fa0c7766539"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optimised FFT subroutine with a simple interface.  <a href="#a15696f881fa3811525c41fa0c7766539">More...</a><br /></td></tr>
<tr class="separator:a15696f881fa3811525c41fa0c7766539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7002bc11f2855eddb1136ab8ad78a132"><td class="memItemLeft" align="right" valign="top">Module: $math.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fft_8asm.html#a7002bc11f2855eddb1136ab8ad78a132">ifft</a> </td></tr>
<tr class="memdesc:a7002bc11f2855eddb1136ab8ad78a132"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optimised IFFT subroutine with a simple interface.  <a href="#a7002bc11f2855eddb1136ab8ad78a132">More...</a><br /></td></tr>
<tr class="separator:a7002bc11f2855eddb1136ab8ad78a132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15120efd44192efdf656c3d3f577e486"><td class="memItemLeft" align="right" valign="top">Module: $math.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fft_8asm.html#a15120efd44192efdf656c3d3f577e486">scaleable_fft</a> </td></tr>
<tr class="memdesc:a15120efd44192efdf656c3d3f577e486"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optimised scaleable FFT subroutine with a simple interface.  <a href="#a15120efd44192efdf656c3d3f577e486">More...</a><br /></td></tr>
<tr class="separator:a15120efd44192efdf656c3d3f577e486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b526da6bb1492a6700ec25bdb09100"><td class="memItemLeft" align="right" valign="top">Module: $math.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fft_8asm.html#ab0b526da6bb1492a6700ec25bdb09100">scaleable_ifft</a> </td></tr>
<tr class="memdesc:ab0b526da6bb1492a6700ec25bdb09100"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optimised scaleable IFFT subroutine with a simple interface.  <a href="#ab0b526da6bb1492a6700ec25bdb09100">More...</a><br /></td></tr>
<tr class="separator:ab0b526da6bb1492a6700ec25bdb09100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987f4b3bbd50be509cc8900014790ed3"><td class="memItemLeft" align="right" valign="top">Module: $math.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fft_8asm.html#a987f4b3bbd50be509cc8900014790ed3">bitreverse_array</a> </td></tr>
<tr class="memdesc:a987f4b3bbd50be509cc8900014790ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A routine to bit-reverse an array.  <a href="#a987f4b3bbd50be509cc8900014790ed3">More...</a><br /></td></tr>
<tr class="separator:a987f4b3bbd50be509cc8900014790ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a8a53085d16973de2fd0e09ae383a1"><td class="memItemLeft" align="right" valign="top">Module: $math.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fft_8asm.html#ae8a8a53085d16973de2fd0e09ae383a1">load_fft_twiddle_factors</a> </td></tr>
<tr class="memdesc:ae8a8a53085d16973de2fd0e09ae383a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A routine to load fft twiddle factors from flash.  <a href="#ae8a8a53085d16973de2fd0e09ae383a1">More...</a><br /></td></tr>
<tr class="separator:ae8a8a53085d16973de2fd0e09ae383a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><em>[SDK Folder]</em>/src/kalimba/math/fft.asm</p>
<p>Part of ADK_CSR867x.WIN. 4.4</p>
<p>/*! </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a987f4b3bbd50be509cc8900014790ed3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$math bitreverse_array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A routine to bit-reverse an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>I4 = pointer to input array</li>
<li>I0 = bit reversed pointer to output array</li>
<li>r10 = array size (must be an integer power of two)</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>None</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r0, r1, I0, I4, M1, M2</dd>
</dl>
<dl>
<dt><b>CPU USAGE:</b></dt>
<dd>10 + N Cycles </dd>
</dl>
<dl>
<dt><b>Notes:</b></dt>
<dd>1) The output buffer must have ben declared as circular so that the bitreverse addressing to operate correctly. 2) Input and output buffers cannot overlap in memory 3) The bit reverse flag in rFlags WILL BE CLEARED after this function </dd>
</dl>

</div>
</div>
<a class="anchor" id="a15696f881fa3811525c41fa0c7766539"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$math fft </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An optimised FFT subroutine with a simple interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>I7 = pointer to fft structure:<ul>
<li>$fft.NUM_POINT_FIELD - number of data points</li>
<li>$fft.REAL_FIELD - ptr to real input data (becomes output data)</li>
<li>$fft.IMAG_FIELD - ptr to imag input data (becomes output data)</li>
<li>for minimum CPU cycles real and imag buffers must be in different memory banks</li>
</ul>
</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>The structure pointed to by I7, remains unaltered, but as this is an inplace implementation the input buffers become the output buffers. These output buffers are in bit reversed order</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>- r0 - r10, DoLoop, I0 - I6, M0 - M3</dd>
</dl>
<dl>
<dt><b>CPU USAGE:</b></dt>
<dd><pre class="fragment">   No.fft pts:      16    32     64    128     256     512    1024     2048

   No. Clks (BC5): 421   930   2063   4572   10089   22134   48259   104592</pre><p class="enddd"></p>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a7002bc11f2855eddb1136ab8ad78a132"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$math ifft </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An optimised IFFT subroutine with a simple interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>I7 = pointer to fft structure:<ul>
<li>$fft.NUM_POINT_FIELD - number of data points</li>
<li>$fft.REAL_FIELD - ptr to real input data (becomes output data)</li>
<li>$fft.IMAG_FIELD - ptr to imag input data (becomes output data)</li>
<li>for minimum CPU cycles real and imag buffers must be in different memory banks</li>
</ul>
</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>The structure pointed to by I7, remains unaltered, but as this is an inplace implementation the input buffers become the output buffers. These output buffers are in bit reversed order</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>- r0 - r10, DoLoop, I0 - I6, M0 - M3</dd>
</dl>
<dl>
<dt><b>CPU USAGE:</b></dt>
<dd><pre class="fragment">   No.fft pts:      16    32     64    128     256     512    1024     2048

   No. Clks (BC5): 428   945   2094   4635   10216   22389   48770   105615</pre><p class="enddd"></p>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ae8a8a53085d16973de2fd0e09ae383a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$math load_fft_twiddle_factors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A routine to load fft twiddle factors from flash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>r0 = number of fft points needed (should be a power of 2 up to $fft.NUM_POINTS)</li>
<li>r1 = pointer to a buffer to load the real twiddle factors into</li>
<li>r2 = pointer to a buffer to load the imaginary twiddle factors into</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>Nothing</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>- r0-r6, doLoop, I0, I1, I4, M0, M1</dd>
</dl>
<dl>
<dt><b>CPU USAGE:</b></dt>
<dd><ul>
<li></li>
</ul>
</dd>
</dl>
<dl>
<dt><b>Notes:</b></dt>
<dd>1) loads $fft.twiddle_real_address and $fft.twiddle_imag_address with r1 and r2 </dd>
</dl>

</div>
</div>
<a class="anchor" id="a15120efd44192efdf656c3d3f577e486"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$math scaleable_fft </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An optimised scaleable FFT subroutine with a simple interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>I7 = pointer to fft structure:<ul>
<li>$fft.NUM_POINT_FIELD - number of data points</li>
<li>$fft.REAL_FIELD - ptr to real input data (becomes output data)</li>
<li>$fft.IMAG_FIELD - ptr to imag input data (becomes output data)</li>
<li>for minimum CPU cycles real and imag buffers must be in different memory banks</li>
</ul>
</li>
<li>r8 = scaling value (1.0 for fft is standard, 0.5 for ifft is standard)<ul>
<li>This scaling factor is applied per fft stage.</li>
<li>Hence for a 2^5 = 32 point fft, having a scaling factor of 0.8 will produce an fft output that is scaled by 0.8^5 = 0.32768</li>
</ul>
</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>The structure pointed to by I7, remains unaltered, but as this is an inplace implementation the input buffers become the output buffers. These output buffers are in bit reversed order</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r1 - r10, I0 - I6, M0 - M3</dd>
</dl>
<dl>
<dt><b>CPU USAGE:</b></dt>
<dd><p class="startdd">!!!! NEEDS UPDATING !!!!! </p><pre class="fragment">   No.fft pts:      16     32     64    128     256     512    1024     2048

   No. Clks (BC5): 474   1071   2412   5401   12006   26483   57984   126093</pre><p class="enddd"></p>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ab0b526da6bb1492a6700ec25bdb09100"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">$math scaleable_ifft </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An optimised scaleable IFFT subroutine with a simple interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">INPUTS</td><td><ul>
<li>I7 = pointer to fft structure:<ul>
<li>$fft.NUM_POINT_FIELD - number of data points</li>
<li>$fft.REAL_FIELD - ptr to real input data (becomes output data)</li>
<li>$fft.IMAG_FIELD - ptr to imag input data (becomes output data)</li>
</ul>
</li>
<li>r8 = scaling value (1.0 for fft is standard, 0.5 for ifft is standard)</li>
</ul>
</td></tr>
    <tr><td class="paramname">OUTPUTS</td><td><ul>
<li>The structure pointed to by I7, remains unaltered, but as this is an inplace implementation the input buffers become the output buffers. These output buffers are in bit reversed order</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt><b>Trashed Registers:</b></dt>
<dd>r1 - r10, I0 - I6, M0 - M3</dd>
</dl>
<dl>
<dt><b>CPU USAGE:</b></dt>
<dd><p class="startdd">!!!! NEEDS UPDATING !!!!! </p><pre class="fragment">   No.fft pts:      16     32     64    128     256     512    1024     2048

   No. Clks (BC5): 474   1071   2412   5401   12006   26483   57984   126093</pre><p class="enddd"></p>
</dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 3 2018 03:05:07 for Kalimba DSP Reference Guide by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
